# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview & Vision

### What is GongMuTalk?

GongMuTalk (공무톡) is a Flutter-based comprehensive asset management and community platform for public servants in Korea. The app provides salary/pension calculators, community features, professional matching, and life management tools.

### Why GongMuTalk?

- **Complex Salary Calculations**: Korean public servant compensation involves intricate grade systems, allowances, and tax calculations
- **Information Asymmetry**: Career-specific information is scattered and hard to access
- **Community Need**: Public servants need a trusted space to share career insights and experiences
- **Career Management Gap**: Lack of integrated tools for salary planning, pension estimation, and career progression

### Core Value Proposition

1. **Accurate Financial Planning**: Precise salary and pension calculators based on official government data
2. **Career Track Verification**: OCR-based paystub verification for authentic community access
3. **Hierarchical Lounges**: Career-specific communities (e.g., elementary teachers, firefighters, tax officials)
4. **Privacy-First**: Semi-anonymous system protecting user identity while maintaining accountability

## How to Use This Document

### Purpose of This Document

This is a **living guideline**, not a rigid rulebook:
- ✅ Provides **principles** for consistent decision-making
- ✅ Captures **recurring patterns** and trade-offs
- ❌ Does NOT cover every edge case
- ❌ Does NOT require updates for minor variations

### How to Read This Document

**"Principles > Patterns > Examples > Numbers"**

When guidance conflicts, follow this hierarchy:
1. **Non-Negotiable Principles** (e.g., "No Code Generation")
2. **Core Project Principles** (e.g., "Single Responsibility > File Size")
3. **Recurring Patterns** (e.g., "Cubit for Repository calls")
4. **Guideline Numbers** (e.g., "400 lines") - References, not rules

**For AI Agents**:
- Don't ask to change Non-Negotiable Principles
- Use Core Principles to resolve ambiguous cases
- Numbers are guides - focus on the principle behind them

---

### 🚫 Non-Negotiable Principles

**These are permanent project decisions** - AI should NEVER suggest alternatives:

#### 1. Clean Architecture (Domain/Data/Presentation)
- ✅ Repository interfaces in domain layer
- ✅ Implementations in data layer
- ✅ Clear separation of concerns
- ❌ NO mixing layers
- ❌ NO direct Firebase calls from presentation

```dart
// ✅ Good: Clean separation
// domain/repositories/post_repository.dart
abstract class PostRepository {
  Future<Either<Failure, List<Post>>> fetchPosts();
}

// data/repositories/post_repository_impl.dart
class PostRepositoryImpl implements PostRepository {
  final PostDataSource _dataSource;
  // Implementation
}

// ❌ Bad: Direct Firebase in presentation
class PostCard extends StatelessWidget {
  Widget build(context) {
    FirebaseFirestore.instance.collection('posts').get(); // NO!
  }
}
```

#### 2. BLoC/Cubit for State Management
- ✅ BLoC/Cubit only for all state management
- ✅ flutter_bloc, bloc_concurrency
- ❌ NO Riverpod
- ❌ NO Provider
- ❌ NO GetX, Redux, MobX

```dart
// ✅ Good: Use Cubit
class CommunityCubit extends Cubit<CommunityState> {
  Future<void> fetchPosts() async { }
}

// ❌ Bad: Don't suggest alternatives
final postsProvider = StateNotifierProvider(...); // NO Riverpod!
```

#### 3. GetIt for Manual Dependency Injection
- ✅ Manual registration in `lib/di/di.dart`
- ✅ Explicit dependency graph
- ❌ NO Injectable (code generation)
- ❌ NO get_it_injectable
- ❌ NO auto-registration

```dart
// ✅ Good: Manual registration in di/di.dart
final getIt = GetIt.instance;

Future<void> configureDependencies() async {
  getIt.registerLazySingleton<CommunityRepository>(
    () => CommunityRepositoryImpl(dataSource: getIt()),
  );
}

// ❌ Bad: Don't use Injectable
@module  // NO!
@injectable  // NO!
```

#### 4. Equatable for Entities (Not Freezed)
- ✅ Manual copyWith implementation
- ✅ Manual props override
- ✅ Explicit and debuggable
- ❌ NO Freezed
- ❌ NO json_serializable (unless absolutely necessary)

```dart
// ✅ Good: Use Equatable
class Post extends Equatable {
  const Post({required this.id, required this.title});
  
  final String id;
  final String title;
  
  @override
  List<Object?> get props => [id, title];
  
  Post copyWith({String? id, String? title}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
    );
  }
}

// ❌ Bad: Don't suggest Freezed
@freezed  // NO!
class Post with _$Post {  // NO!
```

#### 5. Firebase as Backend
- ✅ Firestore, Functions, Auth, Storage, Messaging
- ✅ Firebase Crashlytics
- ❌ NO Supabase
- ❌ NO AWS Amplify
- ❌ NO other backend services

#### 6. 🚫 Code Generation is STRICTLY PROHIBITED

**절대 사용 금지**:
- ❌ **freezed** (과거 calculator feature에서 빌드 에러 다수 발생)
- ❌ **build_runner** (일체 사용 금지)
- ❌ json_serializable
- ❌ injectable
- ❌ retrofit_generator
- ❌ Any package requiring code generation

**Historical Context**:
- Freezed caused build failures in calculator feature
- Generated code was harder to debug
- build_runner added complexity and slow compile times

**AI Agent Instruction**: 
Even if the user asks "Should we use Freezed?", the answer is **NO**. 
Politely explain we use Equatable instead due to past issues.

```dart
// ❌ NEVER suggest these
import 'package:freezed_annotation/freezed_annotation.dart';  // NO!
part 'post.freezed.dart';  // NO!

flutter pub run build_runner build  // NO!
```

---

### Core Project Principles

**우선순위 순서** - When principles conflict, prioritize upper ones:

#### 1️⃣ 사용자 신뢰 > 개발 속도

**User trust is paramount, especially for financial calculations**

- Salary/Pension calculations: Slow but accurate (Tier 1 tests 90%+)
- Financial data validation: Non-negotiable
- Never rush critical path features

```dart
// ✅ Good: Slow but validated
final salary = await salaryService.calculateWithValidation(
  profile: profile,
  crossCheckWithOfficialData: true,
);

// ❌ Bad: Fast but unvalidated
final salary = profile.baseSalary * 12; // Too simplistic!
```

#### 2️⃣ 실용주의 > 완벽주의

**80% done and shipped > 100% perfect but delayed**

- Ship with 80% completion if core value is delivered
- Don't force Cubit if StatefulWidget is more natural
- Prefer working code over perfect architecture

```dart
// ✅ Good: Simple animation with StatefulWidget
class _MenuAnimationState extends State with TickerProviderStateMixin {
  late AnimationController _controller;
  // Pure animation logic - StatefulWidget is fine
}

// ❌ Bad: Over-engineering
class MenuAnimationCubit extends Cubit<MenuAnimationState> {
  // Don't force Cubit for simple animations!
}
```

#### 3️⃣ 단일 책임 > 파일 크기

**Single Responsibility Principle > Line Count**

- 600 lines is OK if single responsibility
- 300 lines needs refactoring if multiple responsibilities
- Focus on "What does this file do?" not "How long is it?"

```dart
// ✅ Good: 592 lines, single responsibility (Staggered Animation)
// lib/features/community/presentation/widgets/lounge_floating_menu.dart
class _LoungeFloatingMenuState extends State {
  // All animation-related logic
}

// ❌ Bad: 860 lines, multiple responsibilities
// lib/features/community/presentation/widgets/post_card.dart
class _PostCardState extends State {
  Future<void> _loadComments() { }  // Responsibility 1
  Future<void> _uploadImage() { }   // Responsibility 2
  Future<void> _sharePost() { }     // Responsibility 3
  void _showMenu() { }              // Responsibility 4
}
```

#### 4️⃣ 명시적 > 암시적

**Explicit > Implicit (Debuggability First)**

- Code generation < Manual implementation
- Auto DI < Manual registration
- Magic < Explicit code

**Why**: Easier debugging, clearer control flow

```dart
// ✅ Good: Explicit GetIt registration
getIt.registerLazySingleton<CommunityRepository>(
  () => CommunityRepositoryImpl(
    dataSource: getIt<PostDataSource>(),
  ),
);

// ❌ Bad: Auto-injection (we don't use this)
@injectable
class CommunityRepository { }  // Magic - hard to debug
```

#### 5️⃣ 테스트 의미 > 커버리지 숫자

**90% meaningful tests > 100% meaningless tests**

- Focus on Tier 1 (Salary/Pension) 90%+ coverage
- Overall 40% is less important than critical path 90%
- Don't test for the sake of coverage percentage

```dart
// ❌ Bad: Meaningless test
test('Post has id field', () {
  expect(post.id, isNotNull); // Useless
});

// ✅ Good: Meaningful test
test('should calculate net salary correctly for grade 15', () {
  final result = service.calculateNetSalary(
    grade: 15,
    allowances: Allowance(family: 100000),
  );
  
  expect(result.gross, 3500000);
  expect(result.tax, 350000);
  expect(result.net, 3150000);
});
```

#### 6️⃣ 비용 최적화 > 개발 편의

**Firestore cost optimization is critical**

- Minimize Firestore queries (caching, pagination required)
- Image compression mandatory
- Monitor Firebase usage regularly

```dart
// ✅ Good: Cached with pagination
final posts = await repository.fetchPosts(
  limit: 20,
  useCache: true,
);

// ❌ Bad: Fetch all documents
final posts = await postsRef.get(); // $$$!
```

---

### Common Trade-Off Decisions

**Quick reference for AI agents when making decisions**:

#### 속도 vs 품질 (Speed vs Quality)
- **Tier 1** (Salary/Pension): Quality first (90%+ tests, slow is OK)
- **Tier 2** (Repository/Service): Balanced (60-70% tests)
- **Tier 3** (UI/Cubit): Speed first (tests optional)

#### Cubit vs StatefulWidget
```
Repository/Service calls? → Cubit 필수
Business logic? → Cubit 필수
Complex state (loading/data/error)? → Cubit 필수
Pure UI animation? → StatefulWidget OK
Simple form (local state only)? → StatefulWidget OK
```

#### 파일 분리 vs 유지 (Split vs Keep)
```
Multiple responsibilities mixed? → Split immediately
5+ private widgets? → Consider splitting
Complex but single responsibility? → Keep OK
```

#### 테스트 작성 vs 생략 (Test vs Skip)
```
Tier 1 (Salary/Pension calculations)? → Test required (90%+)
Tier 2 (Repositories/Services)? → Test recommended (60-70%)
Tier 3 (Cubits)? → Test complex ones (40%+)
Simple UI animations? → Skip OK
```

#### 추상화 vs 구체성 (Abstraction vs Concreteness)
- **Domain Layer**: Abstraction (repository interfaces)
- **Data Layer**: Concreteness (Firebase implementations)
- **Presentation**: Concreteness (Material 3 widgets directly)

---

### Before Modifying This Document

**Checklist for AI agents before updating CLAUDE.md**:

#### ✅ DO Update the Document When:

**1. New Recurring Pattern Discovered (5+ times)**
```
Example: "Same caching pattern used in CommentCard, PostCard, ProfileCard"
→ Add to "Common Patterns" section
```

**2. Fundamental Dilemma Not Covered by Existing Principles**
```
Example: "New case where StatefulWidget vs Cubit guidelines don't apply"
→ Add to "Common Trade-Off Decisions"
```

**3. New Firebase Service Added**
```
Example: "Added Firebase ML Kit for paystub OCR"
→ Add to "Firebase Integration" section with patterns
```

**4. New Core Domain Added**
```
Example: "Real estate calculator" (same criticality as salary/pension)
→ Add to "Domain Knowledge" section
```

#### ❌ DON'T Update the Document When:

**1. One-Off Exception Case**
```
Example: "This one widget is 800 lines but it's special"
→ Put in code comment, not in CLAUDE.md
```

**2. Minor Number Adjustments**
```
Example: "Should we change 400 lines to 420 lines?"
→ No, these are guidelines, not exact rules
```

**3. New Example Files**
```
Example: "Let's add another example of good Cubit usage"
→ Existing principles are sufficient
```

**4. Project-Specific Domain Details**
```
Example: "Salary calculation formula changed"
→ Update code/comments only, not CLAUDE.md
```

#### 📝 Document Lifecycle

| Update Type | Frequency | Examples |
|-------------|-----------|----------|
| **Major** | 6+ months | Non-Negotiable principles changed (very rare) |
| **Minor** | 1-2 months | New pattern sections, new trade-off guidelines |
| **Micro** | Weekly | Typos, link fixes, clarifications |
| **None** | - | One-off cases, exceptions, minor variations |

**Guiding Principle**: 
This document captures **recurring decisions**, not individual cases.
One-time decisions belong in code comments or PR descriptions.

---

## Quick Start

### Prerequisites
- Flutter SDK 3.8.1+
- Firebase CLI installed and configured
- Node.js 22+ (for Firebase Functions development)
- Git

### Initial Setup

```bash
# 1. Clone repository
git clone [repository-url]
cd gong_mu_talk

# 2. Install Flutter dependencies
flutter pub get

# 3. Configure Firebase
firebase use <your-project-id>

# 4. Install Firebase Functions dependencies
cd functions
npm install
cd ..

# 5. Start Firebase Emulators (optional, for local development)
firebase emulators:start

# 6. Run the app
flutter run
```

### First-Time Developer Setup

1. **Firebase Configuration**:
   - Obtain `firebase_options.dart` from team lead
   - Place in `lib/` directory
   
2. **Service Account Keys** (for Functions development):
   - Get `serviceAccountKey.json` from Firebase Console
   - Place in `functions/` (gitignored)

3. **Environment Variables**:
   - Create `functions/.env` with required keys
   - See `functions/.env.example` for template

### Verify Setup

```bash
# Check Flutter doctor
flutter doctor

# Verify Firebase connection
firebase projects:list

# Run tests
flutter test

# Build (should complete without errors)
flutter build apk --debug
```

## Development Workflow

### Essential Commands

```bash
# Development
flutter pub get              # Install dependencies
flutter run                  # Run app
flutter analyze              # Static analysis
dart format lib test         # Format code

# Testing
flutter test                 # Run all tests
flutter test test/path/to/test_file.dart  # Run specific test
flutter test --coverage      # Generate coverage report

# Building
flutter build apk            # Android
flutter build ios            # iOS
```

### Firebase Commands

```bash
# Deployment
firebase deploy                          # Deploy all
firebase deploy --only hosting           # Deploy hosting only
firebase deploy --only firestore:indexes # Deploy Firestore indexes
firebase deploy --only functions         # Deploy Functions

# Development
firebase emulators:start                 # Start all emulators
firebase emulators:start --only firestore,auth  # Specific emulators
# Emulator UI: http://localhost:4000

# Functions Development
cd functions
npm install
npm run build
npm run serve    # Start functions emulator
```

### Data Management Scripts

```bash
# Available in scripts/ directory
dart run scripts/export_lounges.dart
dart run scripts/migrate_lounges.dart
dart run scripts/verify_career_lounge_mapping.dart
```

**Note**: Scripts may require Firebase credentials and proper configuration.

### Git Workflow & Commit Conventions

**Commit Types**:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code formatting (no functional changes)
- `refactor`: Code refactoring (no functional changes)
- `test`: Test addition or modification
- `chore`: Build process or auxiliary tools

**Commit Format**:
```
<type>(<scope>): <subject>
```

**Examples**:
```
feat(auth): add social login
fix(api): resolve null reference in user fetch
docs(readme): update setup instructions
refactor(community): extract cache manager service
```

## Architecture

### Project Structure

- **lib/app/**: Main application setup and shell
- **lib/bootstrap/**: Application initialization and dependency injection
- **lib/core/**: Core utilities, constants, configurations, and Firebase setup
- **lib/common/**: Shared widgets and utilities
- **lib/di/**: Dependency injection configuration using GetIt
- **lib/features/**: Feature modules following clean architecture
- **lib/routing/**: GoRouter configuration and navigation

### Feature Module Structure

Most features follow clean architecture with three layers:

```
features/[feature_name]/
├── domain/          # Business logic and entities
│   ├── entities/
│   ├── repositories/  # Repository interfaces
│   └── usecases/
├── data/            # Data layer implementations
│   ├── datasources/
│   ├── models/
│   ├── repositories/  # Repository implementations
│   └── services/      # Business services (caching, enrichment, validation)
└── presentation/    # UI layer
    ├── bloc/        # BLoC pattern state management
    ├── cubit/       # Cubit state management
    ├── views/       # Pages/screens
    ├── widgets/     # Feature-specific widgets
    └── utils/       # Presentation helpers
```

**Variations**:
- **salary_insights**: Simplified structure (domain + presentation only)
- **year_end_tax**: In development (placeholder)

### Key Architectural Patterns

#### 1. Repository Pattern
- **Interface** in domain layer, **implementation** in data layer
- Returns `Either<Failure, Data>` for explicit error handling
- Delegates complex logic to services

```dart
// domain/repositories/post_repository.dart
abstract class PostRepository {
  Future<Either<Failure, List<Post>>> fetchPosts();
}

// data/repositories/post_repository_impl.dart
class PostRepositoryImpl implements PostRepository {
  final PostDataSource _dataSource;
  
  @override
  Future<Either<Failure, List<Post>>> fetchPosts() async {
    try {
      final posts = await _dataSource.fetchPosts();
      return Right(posts);
    } catch (e) {
      return Left(ServerFailure());
    }
  }
}
```

#### 2. Service Layer Pattern

Services handle cross-cutting concerns:
- **CacheManager**: In-memory caching with TTL management
- **EnrichmentService**: Coordinate multiple repositories to enrich entities
- **ValidationService**: Complex validation logic
- **CalculationService**: Complex algorithms (salary, pension calculations)

**Location**: `data/services/` or `domain/services/` depending on dependencies

#### 3. State Management: BLoC/Cubit First (But Pragmatic)

**기본 원칙**: Cubit/BLoC 우선, 하지만 실용적으로 판단

**판단 플로우차트**:
```
Widget이 상태 관리가 필요한가?
│
├─ Repository/Service 호출? → 🔴 Cubit 필수
├─ 복잡한 비즈니스 로직? → 🔴 Cubit 필수
├─ 여러 상태 조합 (loading/data/error)? → 🔴 Cubit 필수
├─ 테스트가 필요한 로직? → 🔴 Cubit 필수
│
└─ 순수 UI만?
   ├─ 애니메이션? → ✅ StatefulWidget OK
   ├─ 간단한 Form (로컬만)? → ✅ StatefulWidget OK
   ├─ 일시적 UI 상태? → ✅ StatefulWidget OK
   └─ 복잡한 Form? → 🟡 FormCubit 권장
```

---

**Cubit 필수인 경우**:

**1. Repository 호출**
```dart
// 🔴 Repository 호출 → Cubit 필수
class _PostCardState extends State<PostCard> {
  late final CommunityRepository _repository; // ❌

  Future<void> _loadComments() async {
    await _repository.fetchComments(...); // ❌ Cubit으로!
  }
}

// ✅ Good: Cubit 사용
class PostCardCubit extends Cubit<PostCardState> {
  PostCardCubit(this._repository) : super(PostCardState.initial());

  final CommunityRepository _repository;

  Future<void> loadComments(String postId) async {
    emit(state.copyWith(isLoading: true));

    final result = await _repository.fetchComments(postId);
    result.fold(
      (failure) => emit(state.copyWith(error: failure.message, isLoading: false)),
      (comments) => emit(state.copyWith(comments: comments, isLoading: false)),
    );
  }
}
```

**2. 복잡한 비즈니스 로직**
```dart
// 🔴 복잡한 비즈니스 로직 → Cubit 필수
class _MyWidgetState extends State<MyWidget> {
  Future<void> _submit() async {
    // ❌ Widget에 비즈니스 로직
    if (user.isVerified && post.isPublic && !post.isReported) {
      // Complex logic...
    }
  }
}

// ✅ Good: 비즈니스 로직은 Cubit에
class PostSubmitCubit extends Cubit<PostSubmitState> {
  Future<void> submit(Post post, User user) async {
    if (!canSubmit(post, user)) {
      emit(PostSubmitState.error('권한 없음'));
      return;
    }

    emit(PostSubmitState.submitting());
    // ... submit logic
  }

  bool canSubmit(Post post, User user) {
    return user.isVerified && post.isPublic && !post.isReported;
  }
}
```

**3. 여러 상태 조합**
```dart
// 🔴 loading + data + error 조합 → Cubit 필수
class _MyWidgetState extends State<MyWidget> {
  bool _isLoading = false;
  List<Post>? _posts;
  String? _error;

  // ❌ 상태 관리 복잡
}

// ✅ Good: Cubit으로 상태 관리
class PostsCubit extends Cubit<PostsState> {
  PostsCubit(this._repository) : super(PostsState.initial());

  Future<void> fetchPosts() async {
    emit(PostsState.loading());

    final result = await _repository.fetchPosts();
    result.fold(
      (failure) => emit(PostsState.error(failure.message)),
      (posts) => emit(PostsState.loaded(posts)),
    );
  }
}
```

---

**StatefulWidget이 OK인 경우**:

**1. 순수 애니메이션**
```dart
// ✅ Good: 순수 애니메이션
class _LoungeMenuState extends State<LoungeMenu>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: Duration(milliseconds: 200),
    );
    _fadeAnimation = Tween<double>(begin: 0, end: 1).animate(_controller);
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  // Animation logic only, no business logic
}
```

**2. 로컬 Form 상태 (간단한 경우)**
```dart
// ✅ Good: Form 로컬 상태만 관리
class _QuickInputSheetState extends State<QuickInputSheet> {
  late int _currentGrade;
  late Position _position;

  @override
  void initState() {
    super.initState();
    _currentGrade = widget.initialProfile?.currentGrade ?? 35;
    _position = widget.initialProfile?.position ?? Position.teacher;
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Slider(
          value: _currentGrade.toDouble(),
          onChanged: (v) => setState(() => _currentGrade = v.toInt()),
        ),
        ElevatedButton(
          onPressed: () {
            // Callback으로 부모에게 전달
            widget.onSubmit(TeacherProfile(
              currentGrade: _currentGrade,
              position: _position,
            ));
          },
          child: Text('제출'),
        ),
      ],
    );
  }
}
// Form 값만 로컬 관리, 제출은 부모에게 위임 → OK
```

**3. 일시적 UI 상태**
```dart
// ✅ Good: 일시적 expand/collapse 상태
class _ExpandableCardState extends State<ExpandableCard> {
  bool _isExpanded = false;

  void _toggle() {
    setState(() => _isExpanded = !_isExpanded);
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _toggle,
      child: AnimatedContainer(
        height: _isExpanded ? 200 : 80,
        // Pure UI state, no business logic
      ),
    );
  }
}
```

**4. 이미지 로딩 상태 (I/O만)**
```dart
// ✅ Good: File I/O만 처리
class _OptimizedImagePreviewState extends State<OptimizedImagePreview> {
  Uint8List? _imageBytes;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadImageBytes();
  }

  Future<void> _loadImageBytes() async {
    final bytes = await widget.imageFile.readAsBytes(); // File I/O only
    if (mounted) {
      setState(() {
        _imageBytes = bytes;
        _isLoading = false;
      });
    }
  }

  // No business logic, just file loading
}
```

---

**경계선 케이스: 복잡한 Form**

```dart
// 🟡 간단한 Form → StatefulWidget OK
class _SimpleFormState extends State<SimpleForm> {
  final _controller = TextEditingController();
  bool _isValid = false;

  @override
  void initState() {
    super.initState();
    _controller.addListener(() {
      setState(() => _isValid = _controller.text.length > 3);
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _submit() {
    if (_isValid) {
      widget.onSubmit(_controller.text); // Just pass to parent
    }
  }

  // Simple validation only, submit via callback → OK
}

// 🔴 복잡한 Form → FormCubit 사용
class CommentFormCubit extends Cubit<CommentFormState> {
  CommentFormCubit(this._repository) : super(CommentFormState.initial());

  final CommunityRepository _repository;

  Future<void> submitComment({
    required String text,
    required List<XFile> images,
  }) async {
    emit(state.copyWith(isSubmitting: true));

    // 1. Upload images
    final uploadResults = await Future.wait(
      images.map((img) => _uploadImage(img)),
    );

    // 2. Submit comment with URLs
    final result = await _repository.addComment(
      text: text,
      imageUrls: uploadResults,
    );

    result.fold(
      (failure) => emit(state.copyWith(
        error: failure.message,
        isSubmitting: false,
      )),
      (_) => emit(CommentFormState.success()),
    );
  }

  Future<String> _uploadImage(XFile image) async {
    // Image upload logic
  }
}
```

---

**실제 프로젝트 예시**:

**✅ StatefulWidget 유지 OK**:
- `optimized_image_preview.dart` - 이미지 로딩 상태만 관리
- `quick_input_bottom_sheet.dart` - Form 로컬 상태, onSubmit으로 위임
- `lounge_floating_menu.dart` - Staggered animation 로직
- `expandable_card.dart` - 일시적 expand 상태

**🚨 Cubit으로 이동 필요**:
- `post_card.dart` - Repository 호출, 댓글 로딩/제출 로직 포함
  - 해결: PostCardCubit (댓글), ImageUploadCubit (이미지) 분리

---

**State Management Stack**:
- **BLoC/Cubit**: 비즈니스 로직, 데이터 로딩, 복잡한 상태 (flutter_bloc, bloc_concurrency)
- **GetIt**: Dependency injection (manual registration)
- **GoRouter**: Navigation with authentication guards
- **StatefulWidget**: 순수 UI/Animation (제한적 사용)

### No Code Generation Policy

**⚠️ This project does NOT use code generation.**

**What We Use Instead**:
1. **Equatable** (instead of Freezed) for immutable entities
2. **Manual GetIt registration** (instead of Injectable) in `lib/di/di.dart`
3. **Manual serialization** (instead of json_serializable)
4. **Dio directly** (instead of Retrofit)

**Why**:
- Freezed caused build failures in calculator feature
- Generated code harder to debug
- build_runner added complexity and slow compile times

**Policy**:
- ❌ DO NOT add: freezed, json_serializable, injectable, retrofit_generator, build_runner
- ✅ Use: Equatable, manual GetIt registration, manual serialization

### Key Dependencies

**Core Firebase**: Core, Auth, Firestore, Storage, Messaging, Crashlytics

**State & Architecture**: flutter_bloc, bloc_concurrency, get_it, dartz (Either/Option), tuple, equatable

**Navigation**: go_router (manual configuration)

**HTTP**: dio, cached_network_image

**UI**: google_fonts, lottie, rive, skeletonizer, fl_chart, image_picker, file_picker, flutter_image_compress

**Error Tracking**: sentry_flutter

**Utilities**: shared_preferences, path_provider, share_plus, url_launcher, logger

**Dev Tools**: flutter_lints, very_good_analysis, bloc_test, mocktail

---

# 🤖 AI Development Guidelines

The following sections are optimized for AI coding agents (Claude Code, GitHub Copilot, etc.) to make better decisions and avoid common mistakes when working on this codebase.

## Decision Trees for AI

### When to Create a New Feature Module

```
User requests new functionality
├─ Is it a core user-facing feature? (calculator, community, auth, etc.)
│  └─ YES → Create full feature module with domain/data/presentation
│     └─ Example: "Add retirement planning feature"
│        ├─ lib/features/retirement_planning/domain/
│        ├─ lib/features/retirement_planning/data/
│        └─ lib/features/retirement_planning/presentation/
│
├─ Is it a helper/utility used across features? (formatters, validators, etc.)
│  └─ YES → Add to lib/core/ or lib/common/
│     └─ Example: "Add phone number formatter"
│        └─ lib/core/utils/phone_formatter.dart
│
└─ Is it feature enhancement/bug fix within existing feature?
   └─ YES → Modify existing feature module
      └─ Example: "Add filter to community feed"
         └─ Modify lib/features/community/
```

### Service vs Repository Decision

```
Need to implement data/business logic?
├─ Single data source + CRUD operations?
│  └─ USE REPOSITORY
│     └─ Example: PostRepository.fetchPosts() → Firestore query
│
├─ Multiple repositories coordination?
│  └─ USE SERVICE (EnrichmentService pattern)
│     └─ Example: PostEnrichmentService coordinates:
│        - PostRepository (fetch posts)
│        - InteractionRepository (fetch likes/bookmarks)
│        - CommentRepository (fetch top comments)
│        - CacheManager (check cache)
│
├─ In-memory caching with TTL?
│  └─ USE SERVICE (CacheManager pattern)
│     └─ Example: InteractionCacheManager
│        - Manages cache lifecycle
│        - TTL tracking
│        - Hit/miss statistics
│
├─ Complex calculations without external data?
│  └─ USE SERVICE (CalculationService pattern)
│     └─ Example: SalaryCalculationService
│        - Grade calculation
│        - Allowance computation
│        - Tax deduction
│
└─ Complex validation logic?
   └─ USE SERVICE (ValidationService pattern)
      └─ Example: PaystubValidationService
         - OCR result validation
         - Career track detection
         - Format verification
```

### Cubit vs BLoC Decision

```
Need state management?
├─ Simple state with 1-3 methods?
│  └─ USE CUBIT
│     └─ Example: ThemeCubit (toggleTheme)
│
├─ Complex state with events and event transformers?
│  └─ USE BLOC (rare in this project)
│     └─ Example: SearchBloc with debounce
│
├─ Form handling?
│  └─ USE CUBIT (always)
│     └─ Example: CommentFormCubit
│
└─ API calls and data loading?
   └─ USE CUBIT (default choice)
      └─ Example: CommunityCubit
```

### When to Extract Widgets

```
Widget file size check:
├─ 5+ private widgets in single file?
│  └─ EXTRACT IMMEDIATELY
│     └─ Create widgets/[feature_name]/[concern].dart
│        └─ Example: post_card.dart (885 lines)
│           - Extract to widgets/post/comment_section.dart
│           - Extract to widgets/post/like_button.dart
│           - Extract to widgets/post/share_handler.dart
│
├─ Complex widget with 400+ lines?
│  └─ REVIEW FOR EXTRACTION
│     └─ Check if single responsibility
│        - If multiple concerns → Split by concern
│        - If single concern → Keep together (may be acceptable)
│
└─ Widget reused in 2+ places?
   └─ EXTRACT TO common/ OR widgets/
      └─ Example: LoadingButton used everywhere
         └─ lib/common/widgets/loading_button.dart
```

## GongMuTalk Domain Knowledge

### Korean Public Servant Salary System

**Core Concepts AI Must Understand**:

```dart
// Grade System (호봉)
// - Determines base salary
// - Increases annually (usually)
// - Range: 1-40+ depending on career track
int grade = 15; // 15호봉

// Career Track (직렬)
// - Determines job category and salary table
// - Examples: 교육공무원(educators), 소방(firefighters), 세무(tax officials)
String careerTrack = '교육공무원';

// Allowances (수당)
// - Multiple types: family, meal, commute, regional, etc.
// - Different rules per career track
Map<String, int> allowances = {
  'family': 100000,  // 가족수당
  'meal': 130000,    // 식비
  'commute': 50000,  // 교통비
  'position': 200000, // 직급보조비
};

// Tax Deductions (세금)
// - National tax (국세)
// - Local tax (지방세)
// - National pension (국민연금)
// - Health insurance (건강보험)
// - Employment insurance (고용보험)
```

**Salary Calculation Flow**:
```
1. Determine base salary from grade + career track table
2. Add all applicable allowances
3. Calculate gross salary
4. Deduct taxes (progressive rates)
5. Deduct social insurance
6. Result = net salary (실수령액)
```

### Career Track Verification System

**How Paystub OCR Works**:

```
User uploads paystub image/PDF
├─ 1. Vision API extracts text
│     └─ Returns raw OCR text
│
├─ 2. Career track detection
│     └─ Match keywords in text:
│        - "교육공무원" → Elementary/Middle/High School Teacher
│        - "소방" → Firefighter
│        - "세무" → Tax Official
│        - "경찰" → Police Officer
│        └─ Use massive keyword mapping (functions/src/paystubVerification.ts)
│
├─ 3. Salary verification
│     └─ Extract numeric values
│        - Base salary matches grade?
│        - Allowances reasonable?
│
└─ 4. Update user profile
      └─ Set career track
      └─ Mark as verified
      └─ Grant lounge access
```

**Important**: If you modify career verification, understand that it affects:
- User authentication level
- Lounge access permissions
- Community visibility
- Salary calculator accuracy

### Lounge Hierarchy System

**Structure**:
```
Lounges (라운지)
├─ Root Lounges (직렬 라운지)
│  ├─ 교육공무원 (Educators)
│  ├─ 소방공무원 (Firefighters)
│  ├─ 세무공무원 (Tax Officials)
│  └─ ...
│
└─ Sub-Lounges (세부 직렬 라운지)
   └─ 교육공무원
      ├─ 초등교사 (Elementary Teachers)
      ├─ 중등교사 (Middle School Teachers)
      ├─ 고등교사 (High School Teachers)
      └─ 교육전문직 (Education Specialists)
```

**Access Rules**:
- Unverified users: See only public posts
- Verified users: Access their career track lounge + sub-lounges
- Posts in lounges are semi-anonymous (position shown, not full name)

**When Building Lounge Features**:
- Always check user verification status
- Filter posts by lounge membership
- Respect hierarchy (sub-lounge users can see parent lounge)
- Handle anonymous/semi-anonymous display logic

### Semi-Anonymous System

**Key Concept**: Users are authenticated but displayed semi-anonymously

```dart
// Real user data
User {
  uid: "abc123",
  name: "김철수",
  careerTrack: "교육공무원",
  position: "초등교사",
  verified: true,
}

// Displayed in community
Post {
  author: "초등교사 5년차", // Position + years, NO name
  content: "...",
  lounge: "교육공무원/초등교사",
}
```

**Privacy Protection Rules**:
- ✅ Show: Career track, position, years of service
- ❌ Hide: Name, specific workplace, exact location
- ✅ Show only in lounge: Detailed career info
- ❌ Never show publicly: Contact info, government ID

## Common Patterns & Anti-Patterns

### ✅ DO: Use Either Pattern for Error Handling

```dart
// ✅ Good: Repository returns Either
Future<Either<Failure, List<Post>>> fetchPosts() async {
  try {
    final posts = await _dataSource.fetchPosts();
    return Right(posts);
  } on ServerException {
    return Left(ServerFailure());
  } on NetworkException {
    return Left(NetworkFailure());
  } catch (e) {
    return Left(UnknownFailure());
  }
}

// ✅ Good: Cubit handles Either
Future<void> loadPosts() async {
  emit(CommunityState.loading());

  final result = await _repository.fetchPosts();
  result.fold(
    (failure) => emit(CommunityState.error(failure.message)),
    (posts) => emit(CommunityState.loaded(posts)),
  );
}

// ❌ Bad: Throwing exceptions directly
Future<List<Post>> fetchPosts() async {
  final posts = await _dataSource.fetchPosts(); // Throws!
  return posts; // Caller has no type-safe error handling
}
```

### ✅ DO: Manual GetIt Registration

```dart
// ✅ Good: Manual registration in lib/di/di.dart
final GetIt getIt = GetIt.instance;

Future<void> configureDependencies() async {
  // Repositories (singletons)
  getIt.registerLazySingleton<CommunityRepository>(
    () => CommunityRepository(
      postDataSource: getIt(),
      cacheManager: getIt(),
      enrichmentService: getIt(),
    ),
  );

  // Cubits (factories - new instance each time)
  getIt.registerFactory<CommunityCubit>(
    () => CommunityCubit(repository: getIt()),
  );
}

// ❌ Bad: Using Injectable or any code generation
@module
abstract class AppModule {
  @lazySingleton
  CommunityRepository get repository; // DON'T DO THIS
}
```

### ✅ DO: Use Equatable for Entities

```dart
// ✅ Good: Equatable for value equality
class Post extends Equatable {
  const Post({
    required this.id,
    required this.title,
    required this.content,
  });

  final String id;
  final String title;
  final String content;

  @override
  List<Object?> get props => [id, title, content];

  Post copyWith({
    String? id,
    String? title,
    String? content,
  }) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      content: content ?? this.content,
    );
  }
}

// ❌ Bad: Using Freezed
@freezed
class Post with _$Post {
  const factory Post({
    required String id,
    required String title,
  }) = _Post;
} // DON'T DO THIS - project policy prohibits code generation
```

### ✅ DO: Cache Expensive Firestore Queries

```dart
// ✅ Good: Cache with TTL
class InteractionCacheManager {
  static const Duration _cacheTTL = Duration(minutes: 10);
  DateTime? _lastUpdate;
  Set<String>? _cachedLikedPostIds;

  Future<Set<String>> getLikedPostIds(String uid) async {
    if (_shouldRefresh()) {
      _cachedLikedPostIds = await _fetchFromFirestore(uid);
      _lastUpdate = DateTime.now();
    }
    return _cachedLikedPostIds!;
  }

  bool _shouldRefresh() {
    if (_lastUpdate == null) return true;
    return DateTime.now().difference(_lastUpdate!) > _cacheTTL;
  }
}

// ❌ Bad: Always query Firestore
Future<Set<String>> getLikedPostIds(String uid) async {
  return await _fetchFromFirestore(uid); // Expensive every time!
}
```

### ✅ DO: Pagination with Limit

```dart
// ✅ Good: Paginated queries
Future<List<Post>> fetchPosts({required int limit, DocumentSnapshot? lastDoc}) async {
  var query = _firestore
    .collection('posts')
    .orderBy('createdAt', descending: true)
    .limit(limit);

  if (lastDoc != null) {
    query = query.startAfterDocument(lastDoc);
  }

  final snapshot = await query.get();
  return snapshot.docs.map((doc) => Post.fromJson(doc.data())).toList();
}

// ❌ Bad: Fetching all documents
Future<List<Post>> fetchPosts() async {
  final snapshot = await _firestore.collection('posts').get(); // Gets ALL!
  return snapshot.docs.map((doc) => Post.fromJson(doc.data())).toList();
}
```

### ✅ DO: Dispose Resources

```dart
// ✅ Good: Proper disposal
class _MyWidgetState extends State<MyWidget> {
  late StreamSubscription _subscription;
  late AnimationController _animController;
  late TextEditingController _textController;
  Timer? _debounceTimer;

  @override
  void dispose() {
    _subscription.cancel();
    _animController.dispose();
    _textController.dispose();
    _debounceTimer?.cancel();
    super.dispose();
  }
}

// ❌ Bad: Memory leaks
class _MyWidgetState extends State<MyWidget> {
  late StreamSubscription _subscription;
  // ... other resources

  @override
  void dispose() {
    super.dispose(); // Forgot to dispose resources!
  }
}
```

### ✅ DO: Use BLoC/Cubit, Not StatefulWidget for Logic

```dart
// ✅ Good: Business logic in Cubit
class CommentFormCubit extends Cubit<CommentFormState> {
  CommentFormCubit(this._repository) : super(CommentFormState.initial());

  final CommunityRepository _repository;

  void updateText(String text) {
    emit(state.copyWith(text: text));
  }

  Future<void> submitComment(String postId) async {
    emit(state.copyWith(isSubmitting: true));
    final result = await _repository.addComment(postId, state.text);
    result.fold(
      (failure) => emit(state.copyWith(error: failure.message, isSubmitting: false)),
      (_) => emit(CommentFormState.success()),
    );
  }
}

// ❌ Bad: Business logic in StatefulWidget
class _CommentFormState extends State<CommentForm> {
  final _controller = TextEditingController();
  bool _isSubmitting = false;

  Future<void> _submit() async {
    setState(() => _isSubmitting = true);
    try {
      await repository.addComment(widget.postId, _controller.text); // Hard to test!
    } catch (e) {
      // Error handling mixed with UI
    }
  }
}
```

### ❌ DON'T: Use Code Generation

```dart
// ❌ Bad: Freezed, Injectable, json_serializable
import 'package:freezed_annotation/freezed_annotation.dart';

part 'post.freezed.dart';
part 'post.g.dart';

@freezed
class Post with _$Post {
  factory Post.fromJson(Map<String, dynamic> json) => _$PostFromJson(json);
} // DON'T DO THIS

// ✅ Good: Manual serialization with Equatable
class Post extends Equatable {
  const Post({required this.id, required this.title});

  final String id;
  final String title;

  factory Post.fromJson(Map<String, dynamic> json) => Post(
    id: json['id'] as String,
    title: json['title'] as String,
  );

  Map<String, dynamic> toJson() => {'id': id, 'title': title};

  @override
  List<Object?> get props => [id, title];
}
```

### ❌ DON'T: N+1 Query Loops

```dart
// ❌ Bad: N+1 queries (expensive!)
Future<List<Post>> enrichPostsWithAuthor(List<Post> posts) async {
  final enrichedPosts = <Post>[];
  for (final post in posts) {
    final author = await _firestore.collection('users').doc(post.authorId).get(); // N queries!
    enrichedPosts.add(post.copyWith(author: author));
  }
  return enrichedPosts;
}

// ✅ Good: Batch query with whereIn
Future<List<Post>> enrichPostsWithAuthor(List<Post> posts) async {
  final authorIds = posts.map((p) => p.authorId).toSet().toList();

  // Firestore whereIn supports max 10 items per query
  final authors = <String, User>{};
  for (var i = 0; i < authorIds.length; i += 10) {
    final batch = authorIds.skip(i).take(10).toList();
    final snapshot = await _firestore
      .collection('users')
      .where(FieldPath.documentId, whereIn: batch)
      .get();

    for (final doc in snapshot.docs) {
      authors[doc.id] = User.fromJson(doc.data());
    }
  }

  return posts.map((post) => post.copyWith(author: authors[post.authorId])).toList();
}
```

## AI Workflow Optimization

### Which Files to Read for Different Contexts

**Context: Adding a new field to existing feature**

Priority read order:
1. `lib/features/[feature]/domain/entities/[entity].dart` - Check entity structure
2. `lib/features/[feature]/data/models/[model].dart` - Update model serialization
3. `lib/features/[feature]/presentation/cubit/[feature]_cubit.dart` - Update state if needed
4. `lib/features/[feature]/presentation/views/[feature]_page.dart` - Display new field

**Context: Fixing a bug in community feed**

Priority read order:
1. `lib/features/community/presentation/cubit/community_cubit.dart` - Check state logic
2. `lib/features/community/data/community_repository.dart` - Check data fetching
3. `lib/features/community/data/services/post_enrichment_service.dart` - Check enrichment logic
4. `lib/features/community/data/services/interaction_cache_manager.dart` - Check caching
5. `lib/features/community/presentation/widgets/post_card.dart` - Check UI rendering

**Context: Implementing a new calculator feature**

Priority read order:
1. `lib/features/calculator/` - Study existing calculator structure
2. `lib/features/calculator/domain/usecases/` - Understand calculation patterns
3. `lib/features/pension/` - Similar pattern (pension calculator)
4. `lib/core/utils/number_formatter.dart` - Existing number utilities
5. `CLAUDE.md` - Review calculation service pattern

**Context: Adding Firebase function**

Priority read order:
1. `functions/src/index.ts` - Function exports
2. `functions/src/[similar-function].ts` - Study similar function
3. `CLAUDE.md` - Review Firebase Functions section
4. `functions/package.json` - Available dependencies

**Context: Debugging authentication issue**

Priority read order:
1. `lib/features/auth/presentation/cubit/auth_cubit.dart` - Auth state management
2. `lib/features/auth/data/repositories/auth_repository.dart` - Auth repository
3. `lib/core/firebase/firebase_config.dart` - Firebase setup
4. `lib/routing/app_router.dart` - Navigation guards
5. `test/features/auth/data/auth_user_session_test.dart` - Existing auth tests

**Context: Optimizing performance**

Priority read order:
1. `CLAUDE.md` - Performance & Cost Optimization section
2. `lib/features/community/data/services/interaction_cache_manager.dart` - Caching example
3. `lib/core/utils/image_compression_util.dart` - Image optimization example
4. Large repository files (check for optimization opportunities)

### Reading Strategy by File Size

- **<200 lines**: Read entire file
- **200-500 lines**: Read class signatures, then specific methods as needed
- **500-800 lines**: Read file structure first, then targeted sections
- **800+ lines**: File should be refactored, but if reading: focus on specific methods/classes only

## Naming Conventions

### File Naming

```dart
// ✅ Good: Lowercase with underscores
post_repository.dart
interaction_cache_manager.dart
community_cubit.dart
post_enrichment_service.dart
salary_calculator_page.dart

// ❌ Bad: CamelCase, hyphens, or other formats
PostRepository.dart
interaction-cache-manager.dart
communityCubit.dart
```

### Class Naming

```dart
// ✅ Good: PascalCase, descriptive
class CommunityRepository { }
class PostEnrichmentService { }
class InteractionCacheManager { }
class CommunityCubit extends Cubit<CommunityState> { }

// ❌ Bad: Abbreviations, unclear names
class CommRepo { }  // Too abbreviated
class Service { }   // Too generic
class Manager { }   // What does it manage?
```

### Variable Naming

```dart
// ✅ Good: camelCase, descriptive
final communityRepository = getIt<CommunityRepository>();
final likedPostIds = await cacheManager.getLikedPostIds(uid);
final isSubmitting = state.isSubmitting;

// ❌ Bad: Abbreviations, unclear
final repo = getIt<CommunityRepository>();
final ids = await cacheManager.getLikedPostIds(uid);
final flag = state.isSubmitting;
```

### Method Naming

```dart
// ✅ Good: Verb phrases, clear intent
Future<Either<Failure, List<Post>>> fetchPosts();
Future<void> likePost(String postId);
Future<void> clearCache({String? uid});
bool shouldRefreshCache();

// ❌ Bad: Ambiguous or noun-only
Future<Either<Failure, List<Post>>> posts();  // Noun only
Future<void> post(String postId);  // What does this do?
Future<void> cache();  // Clear? Update? Fetch?
```

### State Class Naming

```dart
// ✅ Good: Feature + State
class CommunityState extends Equatable { }
class AuthState extends Equatable { }
class ProfileState extends Equatable { }

// For state variants
class CommunityState {
  const CommunityState.initial();
  const CommunityState.loading();
  const CommunityState.loaded(this.posts);
  const CommunityState.error(this.message);
}

// ❌ Bad: Generic or unclear
class State { }  // Too generic
class Data { }   // Not descriptive
```

### Service/Manager Naming Patterns

```dart
// ✅ Good: Suffix indicates purpose
InteractionCacheManager     // Manages cache
PostEnrichmentService       // Enriches posts
SalaryCalculationService    // Calculates salary
PaystubValidationService    // Validates paystub

// ❌ Bad: Inconsistent or unclear suffixes
InteractionHelper           // Helper is too vague
PostService                 // Service does what?
SalaryUtils                 // Utils is too generic
```

### Cubit Method Naming Patterns

```dart
// ✅ Good: Action verbs
class CommunityCubit extends Cubit<CommunityState> {
  Future<void> fetchPosts() async { }
  Future<void> likePost(String postId) async { }
  Future<void> unlikePost(String postId) async { }
  Future<void> refreshFeed() async { }
  void clearError() { }
}

// ❌ Bad: Ambiguous names
class CommunityCubit extends Cubit<CommunityState> {
  Future<void> load() async { }        // Load what?
  Future<void> update(String id) async { }  // Update what? How?
  Future<void> handle() async { }      // Handle what?
}
```

## AI Testing Checklist

### When Creating a Repository

**Must Test**:
- ✅ Successful data fetch returns `Right(data)`
- ✅ Network error returns `Left(NetworkFailure())`
- ✅ Server error returns `Left(ServerFailure())`
- ✅ Data source called with correct parameters
- ✅ Error handling for each external call

**Example**:
```dart
test('should return Right(posts) when fetch succeeds', () async {
  when(() => dataSource.fetchPosts()).thenAnswer((_) async => [mockPost]);

  final result = await repository.fetchPosts();

  expect(result, Right([mockPost]));
  verify(() => dataSource.fetchPosts()).called(1);
});

test('should return Left(ServerFailure) when data source throws', () async {
  when(() => dataSource.fetchPosts()).thenThrow(ServerException());

  final result = await repository.fetchPosts();

  expect(result, Left(ServerFailure()));
});
```

### When Creating a Service (CacheManager, EnrichmentService, etc.)

**Must Test**:
- ✅ Cache hit returns cached data without external calls
- ✅ Cache miss triggers data fetch
- ✅ TTL expiration triggers refresh
- ✅ Cache statistics tracking (if applicable)
- ✅ Service coordinates multiple repositories correctly

**Example**:
```dart
test('should return cached data when cache is fresh', () {
  cacheManager.updateCache(uid: 'user1', likedIds: {'post1'});

  expect(cacheManager.shouldRefreshCache(), isFalse);
  expect(cacheManager.getLikedPostIds('user1'), {'post1'});
});

test('should refresh cache after TTL expiration', () async {
  cacheManager.updateCache(uid: 'user1', likedIds: {'post1'});

  // Simulate time passage (mock DateTime or use fake_async)
  await Future.delayed(Duration(minutes: 11));

  expect(cacheManager.shouldRefreshCache(), isTrue);
});
```

### When Creating a Cubit

**Must Test**:
- ✅ Initial state is correct
- ✅ State transitions for success case
- ✅ State transitions for error case
- ✅ State transitions for loading case
- ✅ Repository called with correct parameters

**Example** (using bloc_test):
```dart
blocTest<CommunityCubit, CommunityState>(
  'emits [loading, loaded] when fetchPosts succeeds',
  build: () {
    when(() => repository.fetchPosts()).thenAnswer(
      (_) async => Right([mockPost]),
    );
    return CommunityCubit(repository);
  },
  act: (cubit) => cubit.fetchPosts(),
  expect: () => [
    CommunityState.loading(),
    CommunityState.loaded(posts: [mockPost]),
  ],
  verify: (_) {
    verify(() => repository.fetchPosts()).called(1);
  },
);

blocTest<CommunityCubit, CommunityState>(
  'emits [loading, error] when fetchPosts fails',
  build: () {
    when(() => repository.fetchPosts()).thenAnswer(
      (_) async => Left(ServerFailure()),
    );
    return CommunityCubit(repository);
  },
  act: (cubit) => cubit.fetchPosts(),
  expect: () => [
    CommunityState.loading(),
    CommunityState.error(message: 'Server error'),
  ],
);
```

### When Creating a Widget

**Test if**:
- Widget is complex (400+ lines)
- Widget has conditional rendering logic
- Widget handles user interactions
- Widget is reused in multiple places

**Must Test** (if testing):
- ✅ Widget renders without errors
- ✅ Conditional branches render correctly
- ✅ User interactions trigger expected callbacks
- ✅ Edge cases (null data, empty lists, errors)

**Example**:
```dart
testWidgets('should display post content', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: PostCard(post: mockPost),
    ),
  );

  expect(find.text(mockPost.title), findsOneWidget);
  expect(find.text(mockPost.content), findsOneWidget);
});

testWidgets('should call onLike when like button tapped', (tester) async {
  var likeCalled = false;

  await tester.pumpWidget(
    MaterialApp(
      home: PostCard(
        post: mockPost,
        onLike: () => likeCalled = true,
      ),
    ),
  );

  await tester.tap(find.byIcon(Icons.favorite_border));
  expect(likeCalled, isTrue);
});
```

### Coverage Requirements Summary

When implementing new features, ensure:

- ✅ **Domain layer**: 80%+ coverage (entities, usecases)
- ✅ **Services**: 70%+ coverage (cache managers, enrichment services)
- ✅ **Repositories**: 60%+ coverage (data layer)
- ✅ **Cubits**: 50%+ coverage (state management)
- ⚠️ **Widgets**: Test complex widgets only (optional, <50% is acceptable)

**Before submitting PR**:
```bash
flutter test --coverage
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html  # Check coverage report
```

Ensure new code meets minimum 50% coverage before merge.

---

# 🔚 End of AI Development Guidelines

---

## Code Quality & Standards

### File Size Guidelines

**Philosophy**: "Single Responsibility > File Size"

파일 크기는 **단일 책임 원칙**을 위한 지표이지, 절대적 기준이 아닙니다.
줄 수보다 "이 파일이 하나의 명확한 책임만 가지는가?"가 더 중요합니다.

**Zone 기준** (참고용, 절대적 아님):

**UI Files** (views/, widgets/):
- ✅ Green: 0-400 lines (이상적)
- ⚠️ Yellow: 400-600 lines → **단일 책임 검토 필요**
- 🔶 Orange: 600-800 lines → **여러 책임 혼재 가능성 높음**
- 🚨 Red: 800+ lines → **거의 확실히 여러 책임 섞임**

**Logic Files** (cubit/, repositories/, services/):
- ✅ Green: 0-300 lines (이상적)
- ⚠️ Yellow: 300-500 lines → **단일 도메인인지 확인**
- 🔶 Orange: 500-700 lines → **도메인 로직 분리 검토**
- 🚨 Red: 700+ lines → **확실히 분리 필요**

**Domain Files** (entities/, models/, constants/):
- ✅ Green: 0-200 lines (이상적)
- ⚠️ Yellow: 200-400 lines
- 🔶 Orange: 400-600 lines → **상수 데이터면 JSON 이동 고려**
- 🚨 Red: 600+ lines → **데이터와 로직 분리 필요**

---

**분리 판단 기준** (우선순위 순):

**1. ✅ 여러 책임이 섞였는가?** → 즉시 분리

```dart
// ❌ Bad: PostCard가 댓글 관리 + 이미지 업로드 + 공유 + 메뉴
class _PostCardState extends State<PostCard> {
  late final CommunityRepository _repository;

  Future<void> _loadComments() { } // 책임 1: 댓글
  Future<void> _uploadImage() { }  // 책임 2: 이미지
  Future<void> _sharePost() { }    // 책임 3: 공유
  void _showMenu() { }             // 책임 4: 메뉴
}

// ✅ Good: 각각 분리
- PostCard (레이아웃 조립만)
- PostCommentsCubit (댓글 로직)
- ImageUploadCubit (이미지 로직)
- ShareHandler (공유 로직)
- MenuOverlay (메뉴 표시)
```

**2. ⚠️ 5+ private widgets/methods?** → 분리 고려

```dart
// ❌ 5개 이상의 private 위젯 → 별도 파일로
class _MyWidgetState extends State<MyWidget> {
  Widget _buildHeader() { }
  Widget _buildContent() { }
  Widget _buildFooter() { }
  Widget _buildActionBar() { }
  Widget _buildMenu() { }  // 5개!
  Widget _buildComments() { }  // 6개!
}

// ✅ Good: 각각 위젯 파일로 분리
- HeaderWidget (header.dart)
- ContentWidget (content.dart)
- FooterWidget (footer.dart)
- ActionBar (action_bar.dart)
- MenuWidget (menu.dart)
- CommentsSection (comments_section.dart)
```

**3. ⚠️ 복잡한 단일 책임인가?** → 유지 OK

```dart
// ✅ OK: 복잡하지만 "Staggered Animation"이라는 단일 책임
class _LoungeFloatingMenuState extends State<LoungeFloatingMenu>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  List<AnimationController> _itemControllers;
  List<Animation<Offset>> _slideAnimations;
  List<Animation<double>> _fadeAnimations;

  // 600줄이지만 모두 애니메이션 로직
  void _initializeItemAnimations() { }
  void _startStaggeredAnimation() { }
  void _reverseAnimation() { }
  // ... all animation-related
}
// 판정: 단일 책임 (Staggered Menu Animation) → 유지 OK
```

**4. ⚠️ 상수 데이터가 대부분인가?** → JSON/외부 파일로 이동

```dart
// ❌ Bad: 949줄의 상수 데이터
class LoungeDefinitions {
  static const List<Lounge> defaultLounges = [
    Lounge(id: 'teacher', name: '교사', ...),
    Lounge(id: 'firefighter', name: '소방', ...),
    // ... 949 lines of data
  ];
}

// ✅ Good: JSON으로 이동
// assets/data/lounges.json (데이터)
[
  {"id": "teacher", "name": "교사", ...},
  {"id": "firefighter", "name": "소방", ...}
]

// lib/.../lounge_loader.dart (50줄, 로딩 로직만)
class LoungeLoader {
  Future<List<Lounge>> loadLounges() async {
    final json = await rootBundle.loadString('assets/data/lounges.json');
    return (jsonDecode(json) as List).map((e) => Lounge.fromJson(e)).toList();
  }
}
```

---

**유지 가능한 예외** (단일 책임이면 큰 파일도 OK):

**✅ 복잡한 애니메이션 위젯: 600줄까지 OK**
```dart
// 예: Staggered animation with multiple controllers
class _ComplexAnimationState extends State<ComplexAnimation>
    with TickerProviderStateMixin {
  // 10+ AnimationControllers
  // Staggered timing logic
  // Coordinate multiple animations
  // 단일 책임: "Complex coordinated animation"
}
```

**✅ Cubit with 복잡한 상태 관리: 500줄까지 OK**
```dart
// 예: Feed pagination + filtering + sorting + caching
class CommunityFeedCubit extends Cubit<CommunityFeedState> {
  // loadInitial() - pagination logic
  // loadMore() - infinite scroll
  // applyFilter() - filtering
  // changeSort() - sorting
  // _refreshCache() - caching
  // 단일 책임: "Feed state management"
}
```

**✅ 다단계 Form 로직: 400줄까지 OK**
```dart
// 예: Multi-step wizard with validation
class _MultiStepFormState extends State<MultiStepForm> {
  // Step 1, 2, 3 UI
  // Validation for each step
  // Navigation between steps
  // Final submission
  // 단일 책임: "Multi-step form flow"
}
```

**조건**:
- 정말로 **단일 책임**만 가져야 함
- 주석으로 섹션이 명확히 구분되어야 함
- 파일 상단에 책임 명시

---

**실제 프로젝트 예시**:

**✅ 유지 OK**:
- `lounge_floating_menu.dart` (592줄) - 복잡한 staggered animation 로직
  - 단일 책임: "Lounge menu with staggered animations"
- `community_feed_cubit.dart` (501줄) - 피드 상태 관리 (페이지네이션 + 필터 + 정렬)
  - 단일 책임: "Community feed state management"
- `auth_cubit.dart` (496줄) - 인증 상태 관리 (로그인 + 프로필 + 세션)
  - 단일 책임: "Authentication state management"

**🚨 리팩토링 필요**:
- `post_card.dart` (860줄) - 여러 책임 섞임
  - 문제: 댓글 관리 + 이미지 업로드 + 공유 + 메뉴 + 좋아요/북마크
  - 해결: PostCardCubit (댓글), ImageUploadCubit (이미지), ShareHandler (공유) 분리
- `lounge_definitions.dart` (949줄) - 상수 데이터
  - 문제: 코드 파일에 데이터만 949줄
  - 해결: assets/data/lounges.json 이동 + LoungeLoader (50줄)

---

**AI 에이전트를 위한 체크리스트**:

파일 작성/수정 시 다음을 확인하세요:

```
1. 이 파일의 단일 책임은 무엇인가?
   → 한 문장으로 설명 가능? (예: "Post card display and interactions")

2. 5개 이상의 private 메서드/위젯이 있는가?
   → YES: 분리 고려

3. 여러 Repository/Service를 호출하는가?
   → YES: 책임이 섞였을 가능성 높음

4. Yellow Zone 이상인가?
   ├─ YES + 단일 책임 명확 → OK, 유지
   └─ YES + 여러 책임 섞임 → 분리 필요

5. 상수 데이터가 대부분인가?
   → YES: JSON 파일로 이동
```

**결론**: 줄 수는 참고용. **단일 책임**이 핵심 판단 기준입니다.

### Testing Strategy

**Current Status** (As of 2025):
- **Test Files**: 3 files
  - `test/features/auth/data/auth_user_session_test.dart`
  - `test/features/community/data/services/interaction_cache_manager_test.dart` ✅ (모범 사례)
  - `test/models_roundtrip_test.dart`
- **Overall Coverage**: <2%
- **Status**: 🚧 Infrastructure ready, gradual expansion needed

---

**Tier-Based Approach** (계층별 우선순위):

### 🔴 Tier 1 - Critical Path (반드시 테스트)

**금융 로직 수준의 정확도 필요**:

```bash
# 급여 계산 (최우선!)
test/features/calculator/domain/services/salary_calculation_service_test.dart

# 연금 계산
test/features/calculator/domain/services/pension_calculation_service_test.dart

# 인증 및 권한
test/features/auth/presentation/cubit/auth_cubit_test.dart
test/features/community/domain/services/lounge_access_service_test.dart

# 결제/포인트 (있다면)
test/features/*/payment_*_test.dart
```

**목표 커버리지**: **90%+**

**이유**:
- 급여/연금 계산 오류 → 사용자 신뢰 상실
- 인증 오류 → 보안 문제
- 금전적 영향이 직접적

**우선순위**:
1. Week 1-2: 급여 계산 테스트
2. Week 3-4: 연금 계산 테스트
3. Week 5-6: 인증 로직 테스트

---

### 🟡 Tier 2 - Core Business Logic (적극 테스트)

**데이터 무결성 및 비즈니스 로직**:

```bash
# Repositories
test/features/*/data/repositories/*_repository_test.dart

# Domain Services
test/features/*/domain/services/*_service_test.dart

# Cache Managers
test/features/*/data/services/*_cache_manager_test.dart
test/features/*/data/services/*_enrichment_service_test.dart
```

**목표 커버리지**:
- **Repositories**: 60%+
- **Services**: 70%+

**이유**:
- 데이터 일관성 보장
- 캐싱 로직 검증
- API 계약 준수

**테스트 패턴**:
```dart
// Repository 테스트
test('should return Right(data) when fetch succeeds', () async {
  when(() => dataSource.fetchPosts()).thenAnswer((_) async => [mockPost]);

  final result = await repository.fetchPosts();

  expect(result, Right([mockPost]));
  verify(() => dataSource.fetchPosts()).called(1);
});

test('should return Left(ServerFailure) when network fails', () async {
  when(() => dataSource.fetchPosts()).thenThrow(ServerException());

  final result = await repository.fetchPosts();

  expect(result, isA<Left<Failure, List<Post>>>());
});

// Service 테스트
test('should return cached data when cache is fresh', () {
  cacheManager.updateCache(uid: 'user1', likedIds: {'post1'});

  expect(cacheManager.shouldRefreshCache(), isFalse);
  expect(cacheManager.getCachedLikedIds('user1'), {'post1'});
});
```

---

### 🟢 Tier 3 - Presentation Layer (선택적)

**UI 상태 관리**:

```bash
# Cubits (complex state)
test/features/*/presentation/cubit/*_cubit_test.dart

# Widgets (complex only)
test/features/*/presentation/widgets/*_test.dart
```

**목표 커버리지**:
- **Cubits**: 40%+
- **Widgets**: 10-20% (복잡한 것만)

**이유**:
- UI는 빠르게 변하므로 테스트 유지비용 고려
- Cubit은 비즈니스 로직 포함 시 테스트
- Widget은 복잡한 조건부 렌더링만 테스트

**테스트 패턴**:
```dart
// Cubit 테스트 (bloc_test 사용)
blocTest<CommunityCubit, CommunityState>(
  'emits [loading, loaded] when fetchPosts succeeds',
  build: () => CommunityCubit(repository: mockRepository),
  act: (cubit) => cubit.fetchPosts(),
  expect: () => [
    CommunityState.loading(),
    CommunityState.loaded(posts: mockPosts),
  ],
  verify: (_) {
    verify(() => mockRepository.fetchPosts()).called(1);
  },
);

// Widget 테스트 (복잡한 것만)
testWidgets('should render error state when data fails', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: BlocProvider.value(
        value: cubitWithError,
        child: MyComplexWidget(),
      ),
    ),
  );

  expect(find.text('Error occurred'), findsOneWidget);
  expect(find.byType(RetryButton), findsOneWidget);
});
```

---

### 📊 Overall Project Coverage Goals

**현실적 Timeline**:

| Phase | Duration | Target | Focus |
|-------|----------|--------|-------|
| Phase 1 | Week 1-4 | Overall ~8% | Tier 1 급여/연금 90%+ |
| Phase 2 | Month 2-3 | Overall ~20% | Tier 2 Repositories 60%+ |
| Phase 3 | Month 4-6 | Overall ~30% | Tier 2 Services 70%+ |
| Phase 4 | Month 7-12 | Overall ~50% | Tier 3 Cubits 40%+ |

**이유**:
- 현재 <2%에서 40%는 비현실적
- Tier 1 집중이 사용자에게 가장 중요
- 점진적 증가가 지속 가능

**Milestone 체크포인트**:
- ✅ Month 1: 급여 계산 90%+ → "신뢰할 수 있는 계산기"
- ✅ Month 3: Repository 60%+ → "데이터 무결성 보장"
- ✅ Month 6: Overall 30%+ → "업계 스타트업 평균 도달"
- ✅ Year 1: Overall 50%+ → "견고한 프로젝트"

---

### 🎯 Coverage != Quality

**중요한 원칙**:

```
✅ 80%의 의미 있는 테스트 >> 100%의 형식적 테스트

// ❌ Bad: 형식적 테스트
test('model has correct fields', () {
  expect(post.id, isNotNull); // 의미 없음
});

// ✅ Good: 의미 있는 테스트
test('should calculate net salary correctly with grade 15', () {
  final salary = service.calculateNetSalary(
    grade: 15,
    allowances: Allowance(family: 100000),
  );

  expect(salary.gross, 3500000); // 실제 계산 검증
  expect(salary.tax, 350000);
  expect(salary.net, 3150000);
});
```

**테스트하지 않아도 되는 것**:
- Generated code (없지만)
- 단순 getter/setter
- 프레임워크 코드 (Flutter/Firebase)
- 단순 UI 애니메이션

**반드시 테스트해야 하는 것**:
- 급여/연금 계산 로직
- 인증 및 권한 로직
- 데이터 변환 로직
- 에러 처리 로직
- 캐싱 로직

---

### 🛠 Mocking Strategy

**Use mocktail for dependencies**:

```dart
// Mock repositories
class MockCommunityRepository extends Mock implements CommunityRepository {}
class MockAuthCubit extends MockBloc<AuthState> implements AuthCubit {}

// DON'T mock
// ❌ Entities (Post, Comment, User)
// ❌ Value objects (CareerTrack, Allowance)
// ❌ Simple data models
```

---

### 📈 Measuring Success

**Coverage 명령어**:
```bash
# Run tests with coverage
flutter test --coverage

# Generate HTML report
genhtml coverage/lcov.info -o coverage/html

# View report
open coverage/html/index.html
```

**CI/CD Integration**:
```yaml
# .github/workflows/test.yml
- name: Run tests
  run: flutter test --coverage

- name: Check Tier 1 coverage
  run: |
    # Tier 1 (급여/연금) must be 90%+
    # Fail build if below threshold
```

**Coverage Badges** (optional):
```markdown
[![Coverage](https://img.shields.io/badge/coverage-15%25-yellow.svg)]()
[![Tier 1](https://img.shields.io/badge/tier%201-90%25-brightgreen.svg)]()
```

### Linting & Code Quality

- **Base**: flutter_lints (in analysis_options.yaml)
- **Enhanced**: very_good_analysis (available in dev dependencies)
- **Custom rules**: `prefer_const_constructors`, `prefer_const_literals_to_create_immutables`
- **Excluded**: `lib/generated_plugin_registrant.dart`

**Commands**:
```bash
flutter analyze
dart format lib test
flutter test --coverage
```

### Error Tracking

- **Production**: Sentry Flutter (crash reporting, error monitoring)
- **Development**: Firebase Crashlytics

### Code Conventions

**Architecture**:
- Follow Material 3 design guidelines
- Use BLoC/Cubit for state management
- Implement repository pattern for data access
- Isolate Firebase logic in data layer
- Use GetIt for dependency injection (manual registration)
- Use Dartz's `Either<Failure, Success>` for error handling

**Code Quality**:
- Prefer const constructors for performance
- Handle errors gracefully with user feedback
- Write unit tests for business logic
- Dispose resources properly (StreamSubscription, Controllers, Timers)

## Performance & Cost Optimization

### Caching Strategy

**When to Cache**:
- Frequently accessed, rarely changed data
- Expensive Firestore queries (multiple document reads)
- User-specific interactions (likes, bookmarks, view history)
- Computed/aggregated data

**Cache TTL Guidelines**:
- Real-time data (chat): No cache or 30 seconds
- User interactions (likes, bookmarks): 5-10 minutes
- User profiles: 15-30 minutes
- Static content (app settings): 1-24 hours

**Example Pattern**:
```dart
class InteractionCacheManager {
  static const Duration _cacheTTL = Duration(minutes: 10);
  DateTime? _lastCacheUpdate;
  
  bool shouldRefreshCache() {
    if (_lastCacheUpdate == null) return true;
    return DateTime.now().difference(_lastCacheUpdate!) > _cacheTTL;
  }
  
  Map<String, int> getCacheStats() {
    return {
      'hitCount': _cacheHitCount,
      'missCount': _cacheMissCount,
      'savedCost': _cacheHitCount * 2, // Each hit saves 2 Firestore reads
    };
  }
}
```

### Firebase Cost Optimization

**Query Best Practices**:
```dart
// ✅ Good: Use limit for pagination
await postsRef.orderBy('createdAt', descending: true).limit(20).get();

// ✅ Good: Batch queries
await postsRef.where(FieldPath.documentId, whereIn: postIds.take(10)).get();

// ❌ Bad: N+1 queries
for (final postId in postIds) {
  await postsRef.doc(postId).get(); // Expensive!
}

// ❌ Bad: No pagination
await postsRef.orderBy('createdAt').get(); // Gets ALL documents!
```

**Cost Reduction Checklist**:
- ✅ Implement pagination with `.limit()`
- ✅ Cache frequently accessed data
- ✅ Use composite indexes for complex queries
- ✅ Batch reads using `whereIn` (max 10 items per query)
- ❌ Never query entire collections
- ❌ Avoid `.get()` calls inside loops

### Memory Management

**Must Dispose**:
- StreamSubscription
- AnimationController
- TextEditingController
- Timer
- ScrollController
- FocusNode

**Performance Best Practices**:
```dart
// ✅ Use const for static widgets
const Text('Static Label');

// ✅ Extract widgets to reduce rebuilds
class _StaticHeader extends StatelessWidget {
  const _StaticHeader();
}

// ✅ Use keys for list items
ListView.builder(
  itemBuilder: (context, index) {
    return PostCard(
      key: ValueKey(posts[index].id),
      post: posts[index],
    );
  },
);
```

### Image Optimization

**Compression Guidelines**:
```dart
enum ImageCompressionType {
  profile,   // 90%
  post,      // 85%
  comment,   // 80%
  thumbnail, // 70%
}
```

**Best Practices**:
- ✅ Compress before upload
- ✅ Use `cached_network_image` for network images
- ✅ Set `maxWidth` and `maxHeight` when picking
- ✅ Use thumbnails for list views
- ❌ Don't upload raw camera images (can be 5-10MB!)

## Firebase Integration

### Configuration

- Firestore: Primary database
- Firebase Auth: User authentication
- Firebase Storage: File uploads
- Firebase Messaging: Push notifications
- Indexes: Defined in `firestore.indexes.json`
- Emulator: Configured for local development

### Firebase Functions

**Single unified codebase** (`functions/`) handles all backend services:

**Core Features**:
- Community (posts, comments, likes, hot score calculation)
- Paystub Verification (OCR via Vision API, career track detection)
- Email Verification (government email authentication)
- Notifications (push messaging)
- User Management (profile updates, verification status)
- Data Migration utilities

**Tech Stack**:
- Runtime: TypeScript, Node 22
- Core: firebase-admin, firebase-functions
- OCR & Vision: @google-cloud/storage, @google-cloud/vision
- Utilities: nodemailer, pdf-parse

**Development**:
```bash
cd functions
npm install
npm run build
npm run serve  # Start emulator
firebase deploy --only functions
```

**Note**: The `paystub-functions/` directory exists but is not actively used (legacy codebase).

## Troubleshooting

### Common Build Errors

**Q: Gradle build fails with "Execution failed for task ':app:processDebugGoogleServices'"**
```bash
cd android && ./gradlew clean
cd .. && flutter clean && flutter pub get
```

**Q: CocoaPods error on iOS**
```bash
cd ios
pod cache clean --all
pod install
cd ..
```

### Firebase Issues

**Q: "Firebase not initialized" error**
- Ensure `firebase_options.dart` exists in `lib/`
- Verify `Firebase.initializeApp()` is called in `main.dart`

**Q: Functions emulator won't start**
- Check port conflicts (default: 5001 for Functions)
- Change ports in `firebase.json` if needed
- Ensure Node.js 22+ is installed

**Q: Vision API errors in Functions**
- Verify service account has Vision API permissions
- Check `serviceAccountKey.json` is present and valid
- Ensure Vision API is enabled in Google Cloud Console

### Development Issues

**Q: Hot reload not working**
- Restart app completely
- Check for errors in terminal
- Try `flutter clean && flutter pub get`

**Q: Dependency conflicts**
```bash
flutter clean
flutter pub get
flutter pub upgrade
```

**Q: Emulator UI not accessible**
- Check if running: `firebase emulators:start`
- Access at: http://localhost:4000
- Check firewall settings

## Contributing

### Before Starting

1. Read this CLAUDE.md thoroughly
2. Check existing issues/PRs to avoid duplication
3. Discuss major changes in issues first
4. Follow file size and architectural guidelines

### Development Process

1. **Create Feature Branch**:
   ```bash
   git checkout -b feat/your-feature-name
   ```

2. **Write Tests** (50%+ coverage for new features):
   - Unit tests for business logic
   - Widget tests for complex UI
   - BLoC tests for state management

3. **Code Quality Checks**:
   ```bash
   flutter analyze  # Fix all issues
   dart format lib test  # Format code
   flutter test  # All tests must pass
   ```

4. **Submit PR**:
   - Clear, descriptive title
   - Link related issues
   - Describe changes and rationale
   - Include screenshots for UI changes

### Code Review Criteria

- ✅ Follows BLoC/Cubit pattern
- ✅ No code generation dependencies
- ✅ Proper error handling with `Either<Failure, Data>`
- ✅ File size within guidelines
- ✅ Tests written and passing
- ✅ No lint errors
- ✅ Properly disposed resources

### PR Checklist

- [ ] Tests written (50%+ coverage for new code)
- [ ] `flutter analyze` passes with no errors
- [ ] Code formatted with `dart format`
- [ ] No prohibited dependencies (freezed, build_runner, etc.)
- [ ] Follows architectural patterns
- [ ] Documentation updated if needed
- [ ] Tested on both Android and iOS

## Known Issues & Roadmap

### Current Limitations

**Test Coverage**:
- Overall coverage <2%
- Only 3 test files exist
- Critical paths (auth, payments, calculations) need tests
- Gradual expansion to 40%+ planned

**Technical Debt**:
- `post_card.dart` needs refactoring (860 lines, Red Zone)
- `community_repository.dart` should be split (738 lines, Orange Zone)
- Some widgets still use StatefulWidget (migration to Cubit planned)
- `paystub-functions/` directory unused (legacy code)

### In Development

**Year-End Tax Feature**:
- Domain layer complete
- Data and presentation layers in progress
- Target: Q1 2025

**Test Expansion**:
- Auth module tests (Priority 1)
- Calculator/Pension calculation tests (Priority 2)
- Community cache manager tests (In progress)

### Roadmap

**Short-term (Q1 2025)**:
- Complete year-end tax feature
- Expand test coverage to 20%+
- Refactor large files (post_card.dart, community_repository.dart)
- Implement analytics dashboard

**Mid-term (Q2-Q3 2025)**:
- Reach 40%+ overall test coverage
- Performance optimization (reduce Firestore costs by 30%)
- Implement advanced search features
- Add career progression planning tools

**Long-term (Q4 2025+)**:
- AI-powered salary negotiation insights
- Integration with government HR systems
- Mobile web version (PWA)
- Multi-language support

### Reporting Issues

When reporting issues, include:
1. Flutter version (`flutter --version`)
2. Device/emulator details
3. Steps to reproduce
4. Expected vs actual behavior
5. Error logs/screenshots
6. Related code snippets

---

**For questions or clarifications, contact the team lead or open an issue in the repository.**
