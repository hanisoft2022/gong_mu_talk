# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview & Vision

### What is GongMuTalk?

GongMuTalk (ê³µë¬´í†¡) is a Flutter-based comprehensive asset management and community platform for public servants in Korea. The app provides salary/pension calculators, community features, professional matching, and life management tools.

### Why GongMuTalk?

- **Complex Salary Calculations**: Korean public servant compensation involves intricate grade systems, allowances, and tax calculations
- **Information Asymmetry**: Career-specific information is scattered and hard to access
- **Community Need**: Public servants need a trusted space to share career insights and experiences
- **Career Management Gap**: Lack of integrated tools for salary planning, pension estimation, and career progression

### Core Value Proposition

1. **Accurate Financial Planning**: Precise salary and pension calculators based on official government data
2. **Career Track Verification**: OCR-based paystub verification for authentic community access
3. **Hierarchical Lounges**: Career-specific communities (e.g., elementary teachers, firefighters, tax officials)
4. **Privacy-First**: Semi-anonymous system protecting user identity while maintaining accountability

## How to Use This Document

### Purpose of This Document

This is a **living guideline**, not a rigid rulebook:
- âœ… Provides **principles** for consistent decision-making
- âœ… Captures **recurring patterns** and trade-offs
- âŒ Does NOT cover every edge case
- âŒ Does NOT require updates for minor variations

### How to Read This Document

**"Principles > Patterns > Examples > Numbers"**

When guidance conflicts, follow this hierarchy:
1. **Non-Negotiable Principles** (e.g., "No Code Generation")
2. **Core Project Principles** (e.g., "Single Responsibility > File Size")
3. **Recurring Patterns** (e.g., "Cubit for Repository calls")
4. **Guideline Numbers** (e.g., "400 lines") - References, not rules

**For AI Agents**:
- Don't ask to change Non-Negotiable Principles
- Use Core Principles to resolve ambiguous cases
- Numbers are guides - focus on the principle behind them

---

### ğŸš« Non-Negotiable Principles

**These are permanent project decisions** - AI should NEVER suggest alternatives:

#### 1. Clean Architecture (Domain/Data/Presentation)
- âœ… Repository interfaces in domain layer
- âœ… Implementations in data layer
- âœ… Clear separation of concerns
- âŒ NO mixing layers
- âŒ NO direct Firebase calls from presentation

```dart
// âœ… Good: Clean separation
// domain/repositories/post_repository.dart
abstract class PostRepository {
  Future<Either<Failure, List<Post>>> fetchPosts();
}

// data/repositories/post_repository_impl.dart
class PostRepositoryImpl implements PostRepository {
  final PostDataSource _dataSource;
  // Implementation
}

// âŒ Bad: Direct Firebase in presentation
class PostCard extends StatelessWidget {
  Widget build(context) {
    FirebaseFirestore.instance.collection('posts').get(); // NO!
  }
}
```

#### 2. BLoC/Cubit for State Management
- âœ… BLoC/Cubit only for all state management
- âœ… flutter_bloc, bloc_concurrency
- âŒ NO Riverpod
- âŒ NO Provider
- âŒ NO GetX, Redux, MobX

```dart
// âœ… Good: Use Cubit
class CommunityCubit extends Cubit<CommunityState> {
  Future<void> fetchPosts() async { }
}

// âŒ Bad: Don't suggest alternatives
final postsProvider = StateNotifierProvider(...); // NO Riverpod!
```

#### 3. GetIt for Manual Dependency Injection
- âœ… Manual registration in `lib/di/di.dart`
- âœ… Explicit dependency graph
- âŒ NO Injectable (code generation)
- âŒ NO get_it_injectable
- âŒ NO auto-registration

```dart
// âœ… Good: Manual registration in di/di.dart
final getIt = GetIt.instance;

Future<void> configureDependencies() async {
  getIt.registerLazySingleton<CommunityRepository>(
    () => CommunityRepositoryImpl(dataSource: getIt()),
  );
}

// âŒ Bad: Don't use Injectable
@module  // NO!
@injectable  // NO!
```

#### 4. Equatable for Entities (Not Freezed)
- âœ… Manual copyWith implementation
- âœ… Manual props override
- âœ… Explicit and debuggable
- âŒ NO Freezed
- âŒ NO json_serializable (unless absolutely necessary)

```dart
// âœ… Good: Use Equatable
class Post extends Equatable {
  const Post({required this.id, required this.title});
  
  final String id;
  final String title;
  
  @override
  List<Object?> get props => [id, title];
  
  Post copyWith({String? id, String? title}) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
    );
  }
}

// âŒ Bad: Don't suggest Freezed
@freezed  // NO!
class Post with _$Post {  // NO!
```

#### 5. Firebase as Backend
- âœ… Firestore, Functions, Auth, Storage, Messaging
- âœ… Firebase Crashlytics
- âŒ NO Supabase
- âŒ NO AWS Amplify
- âŒ NO other backend services

#### 6. ğŸš« Code Generation is STRICTLY PROHIBITED

**ì ˆëŒ€ ì‚¬ìš© ê¸ˆì§€**:
- âŒ **freezed** (ê³¼ê±° calculator featureì—ì„œ ë¹Œë“œ ì—ëŸ¬ ë‹¤ìˆ˜ ë°œìƒ)
- âŒ **build_runner** (ì¼ì²´ ì‚¬ìš© ê¸ˆì§€)
- âŒ json_serializable
- âŒ injectable
- âŒ retrofit_generator
- âŒ Any package requiring code generation

**Historical Context**:
- Freezed caused build failures in calculator feature
- Generated code was harder to debug
- build_runner added complexity and slow compile times

**AI Agent Instruction**: 
Even if the user asks "Should we use Freezed?", the answer is **NO**. 
Politely explain we use Equatable instead due to past issues.

```dart
// âŒ NEVER suggest these
import 'package:freezed_annotation/freezed_annotation.dart';  // NO!
part 'post.freezed.dart';  // NO!

flutter pub run build_runner build  // NO!
```

---

### Core Project Principles

**ìš°ì„ ìˆœìœ„ ìˆœì„œ** - When principles conflict, prioritize upper ones:

#### 1ï¸âƒ£ ì‚¬ìš©ì ì‹ ë¢° > ê°œë°œ ì†ë„

**User trust is paramount, especially for financial calculations**

- Salary/Pension calculations: Slow but accurate (Tier 1 tests 90%+)
- Financial data validation: Non-negotiable
- Never rush critical path features

```dart
// âœ… Good: Slow but validated
final salary = await salaryService.calculateWithValidation(
  profile: profile,
  crossCheckWithOfficialData: true,
);

// âŒ Bad: Fast but unvalidated
final salary = profile.baseSalary * 12; // Too simplistic!
```

#### 2ï¸âƒ£ ì‹¤ìš©ì£¼ì˜ > ì™„ë²½ì£¼ì˜

**80% done and shipped > 100% perfect but delayed**

- Ship with 80% completion if core value is delivered
- Don't force Cubit if StatefulWidget is more natural
- Prefer working code over perfect architecture

```dart
// âœ… Good: Simple animation with StatefulWidget
class _MenuAnimationState extends State with TickerProviderStateMixin {
  late AnimationController _controller;
  // Pure animation logic - StatefulWidget is fine
}

// âŒ Bad: Over-engineering
class MenuAnimationCubit extends Cubit<MenuAnimationState> {
  // Don't force Cubit for simple animations!
}
```

#### 3ï¸âƒ£ ë‹¨ì¼ ì±…ì„ > íŒŒì¼ í¬ê¸°

**Single Responsibility Principle > Line Count**

- 600 lines is OK if single responsibility
- 300 lines needs refactoring if multiple responsibilities
- Focus on "What does this file do?" not "How long is it?"

```dart
// âœ… Good: 592 lines, single responsibility (Staggered Animation)
// lib/features/community/presentation/widgets/lounge_floating_menu.dart
class _LoungeFloatingMenuState extends State {
  // All animation-related logic
}

// âŒ Bad: 860 lines, multiple responsibilities
// lib/features/community/presentation/widgets/post_card.dart
class _PostCardState extends State {
  Future<void> _loadComments() { }  // Responsibility 1
  Future<void> _uploadImage() { }   // Responsibility 2
  Future<void> _sharePost() { }     // Responsibility 3
  void _showMenu() { }              // Responsibility 4
}
```

#### 4ï¸âƒ£ ëª…ì‹œì  > ì•”ì‹œì 

**Explicit > Implicit (Debuggability First)**

- Code generation < Manual implementation
- Auto DI < Manual registration
- Magic < Explicit code

**Why**: Easier debugging, clearer control flow

```dart
// âœ… Good: Explicit GetIt registration
getIt.registerLazySingleton<CommunityRepository>(
  () => CommunityRepositoryImpl(
    dataSource: getIt<PostDataSource>(),
  ),
);

// âŒ Bad: Auto-injection (we don't use this)
@injectable
class CommunityRepository { }  // Magic - hard to debug
```

#### 5ï¸âƒ£ í…ŒìŠ¤íŠ¸ ì˜ë¯¸ > ì»¤ë²„ë¦¬ì§€ ìˆ«ì

**90% meaningful tests > 100% meaningless tests**

- Focus on Tier 1 (Salary/Pension) 90%+ coverage
- Overall 40% is less important than critical path 90%
- Don't test for the sake of coverage percentage

```dart
// âŒ Bad: Meaningless test
test('Post has id field', () {
  expect(post.id, isNotNull); // Useless
});

// âœ… Good: Meaningful test
test('should calculate net salary correctly for grade 15', () {
  final result = service.calculateNetSalary(
    grade: 15,
    allowances: Allowance(family: 100000),
  );
  
  expect(result.gross, 3500000);
  expect(result.tax, 350000);
  expect(result.net, 3150000);
});
```

#### 6ï¸âƒ£ ë¹„ìš© ìµœì í™” > ê°œë°œ í¸ì˜

**Firestore cost optimization is critical**

- Minimize Firestore queries (caching, pagination required)
- Image compression mandatory
- Monitor Firebase usage regularly

```dart
// âœ… Good: Cached with pagination
final posts = await repository.fetchPosts(
  limit: 20,
  useCache: true,
);

// âŒ Bad: Fetch all documents
final posts = await postsRef.get(); // $$$!
```

---

### Common Trade-Off Decisions

**Quick reference for AI agents when making decisions**:

#### ì†ë„ vs í’ˆì§ˆ (Speed vs Quality)
- **Tier 1** (Salary/Pension): Quality first (90%+ tests, slow is OK)
- **Tier 2** (Repository/Service): Balanced (60-70% tests)
- **Tier 3** (UI/Cubit): Speed first (tests optional)

#### Cubit vs StatefulWidget
```
Repository/Service calls? â†’ Cubit í•„ìˆ˜
Business logic? â†’ Cubit í•„ìˆ˜
Complex state (loading/data/error)? â†’ Cubit í•„ìˆ˜
Pure UI animation? â†’ StatefulWidget OK
Simple form (local state only)? â†’ StatefulWidget OK
```

#### íŒŒì¼ ë¶„ë¦¬ vs ìœ ì§€ (Split vs Keep)
```
Multiple responsibilities mixed? â†’ Split immediately
5+ private widgets? â†’ Consider splitting
Complex but single responsibility? â†’ Keep OK
```

#### í…ŒìŠ¤íŠ¸ ì‘ì„± vs ìƒëµ (Test vs Skip)
```
Tier 1 (Salary/Pension calculations)? â†’ Test required (90%+)
Tier 2 (Repositories/Services)? â†’ Test recommended (60-70%)
Tier 3 (Cubits)? â†’ Test complex ones (40%+)
Simple UI animations? â†’ Skip OK
```

#### ì¶”ìƒí™” vs êµ¬ì²´ì„± (Abstraction vs Concreteness)
- **Domain Layer**: Abstraction (repository interfaces)
- **Data Layer**: Concreteness (Firebase implementations)
- **Presentation**: Concreteness (Material 3 widgets directly)

---

### Before Modifying This Document

**Checklist for AI agents before updating CLAUDE.md**:

#### âœ… DO Update the Document When:

**1. New Recurring Pattern Discovered (5+ times)**
```
Example: "Same caching pattern used in CommentCard, PostCard, ProfileCard"
â†’ Add to "Common Patterns" section
```

**2. Fundamental Dilemma Not Covered by Existing Principles**
```
Example: "New case where StatefulWidget vs Cubit guidelines don't apply"
â†’ Add to "Common Trade-Off Decisions"
```

**3. New Firebase Service Added**
```
Example: "Added Firebase ML Kit for paystub OCR"
â†’ Add to "Firebase Integration" section with patterns
```

**4. New Core Domain Added**
```
Example: "Real estate calculator" (same criticality as salary/pension)
â†’ Add to "Domain Knowledge" section
```

#### âŒ DON'T Update the Document When:

**1. One-Off Exception Case**
```
Example: "This one widget is 800 lines but it's special"
â†’ Put in code comment, not in CLAUDE.md
```

**2. Minor Number Adjustments**
```
Example: "Should we change 400 lines to 420 lines?"
â†’ No, these are guidelines, not exact rules
```

**3. New Example Files**
```
Example: "Let's add another example of good Cubit usage"
â†’ Existing principles are sufficient
```

**4. Project-Specific Domain Details**
```
Example: "Salary calculation formula changed"
â†’ Update code/comments only, not CLAUDE.md
```

#### ğŸ“ Document Lifecycle

| Update Type | Frequency | Examples |
|-------------|-----------|----------|
| **Major** | 6+ months | Non-Negotiable principles changed (very rare) |
| **Minor** | 1-2 months | New pattern sections, new trade-off guidelines |
| **Micro** | Weekly | Typos, link fixes, clarifications |
| **None** | - | One-off cases, exceptions, minor variations |

**Guiding Principle**: 
This document captures **recurring decisions**, not individual cases.
One-time decisions belong in code comments or PR descriptions.

---

## Quick Start

### Prerequisites
- Flutter SDK 3.8.1+
- Firebase CLI installed and configured
- Node.js 22+ (for Firebase Functions development)
- Git

### Initial Setup

```bash
# 1. Clone repository
git clone [repository-url]
cd gong_mu_talk

# 2. Install Flutter dependencies
flutter pub get

# 3. Configure Firebase
firebase use <your-project-id>

# 4. Install Firebase Functions dependencies
cd functions
npm install
cd ..

# 5. Start Firebase Emulators (optional, for local development)
firebase emulators:start

# 6. Run the app
flutter run
```

### First-Time Developer Setup

1. **Firebase Configuration**:
   - Obtain `firebase_options.dart` from team lead
   - Place in `lib/` directory
   
2. **Service Account Keys** (for Functions development):
   - Get `serviceAccountKey.json` from Firebase Console
   - Place in `functions/` (gitignored)

3. **Environment Variables**:
   - Create `functions/.env` with required keys
   - See `functions/.env.example` for template

### Verify Setup

```bash
# Check Flutter doctor
flutter doctor

# Verify Firebase connection
firebase projects:list

# Run tests
flutter test

# Build (should complete without errors)
flutter build apk --debug
```

## Development Workflow

### Essential Commands

```bash
# Development
flutter pub get              # Install dependencies
flutter run                  # Run app
flutter analyze              # Static analysis
dart format lib test         # Format code

# Testing
flutter test                 # Run all tests
flutter test test/path/to/test_file.dart  # Run specific test
flutter test --coverage      # Generate coverage report

# Building
flutter build apk            # Android
flutter build ios            # iOS
```

### Firebase Commands

```bash
# Deployment
firebase deploy                          # Deploy all
firebase deploy --only hosting           # Deploy hosting only
firebase deploy --only firestore:indexes # Deploy Firestore indexes
firebase deploy --only functions         # Deploy Functions

# Development
firebase emulators:start                 # Start all emulators
firebase emulators:start --only firestore,auth  # Specific emulators
# Emulator UI: http://localhost:4000

# Functions Development
cd functions
npm install
npm run build
npm run serve    # Start functions emulator
```

### Data Management Scripts

```bash
# Available in scripts/ directory
dart run scripts/export_lounges.dart
dart run scripts/migrate_lounges.dart
dart run scripts/verify_career_lounge_mapping.dart
```

**Note**: Scripts may require Firebase credentials and proper configuration.

### Git Workflow & Commit Conventions

**Commit Types**:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code formatting (no functional changes)
- `refactor`: Code refactoring (no functional changes)
- `test`: Test addition or modification
- `chore`: Build process or auxiliary tools

**Commit Format**:
```
<type>(<scope>): <subject>
```

**Examples**:
```
feat(auth): add social login
fix(api): resolve null reference in user fetch
docs(readme): update setup instructions
refactor(community): extract cache manager service
```

## Architecture

### Project Structure

- **lib/app/**: Main application setup and shell
- **lib/bootstrap/**: Application initialization and dependency injection
- **lib/core/**: Core utilities, constants, configurations, and Firebase setup
- **lib/common/**: Shared widgets and utilities
- **lib/di/**: Dependency injection configuration using GetIt
- **lib/features/**: Feature modules following clean architecture
- **lib/routing/**: GoRouter configuration and navigation

### Feature Module Structure

Most features follow clean architecture with three layers:

```
features/[feature_name]/
â”œâ”€â”€ domain/          # Business logic and entities
â”‚   â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ repositories/  # Repository interfaces
â”‚   â””â”€â”€ usecases/
â”œâ”€â”€ data/            # Data layer implementations
â”‚   â”œâ”€â”€ datasources/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ repositories/  # Repository implementations
â”‚   â””â”€â”€ services/      # Business services (caching, enrichment, validation)
â””â”€â”€ presentation/    # UI layer
    â”œâ”€â”€ bloc/        # BLoC pattern state management
    â”œâ”€â”€ cubit/       # Cubit state management
    â”œâ”€â”€ views/       # Pages/screens
    â”œâ”€â”€ widgets/     # Feature-specific widgets
    â””â”€â”€ utils/       # Presentation helpers
```

**Variations**:
- **salary_insights**: Simplified structure (domain + presentation only)
- **year_end_tax**: In development (placeholder)

### Key Architectural Patterns

#### 1. Repository Pattern
- **Interface** in domain layer, **implementation** in data layer
- Returns `Either<Failure, Data>` for explicit error handling
- Delegates complex logic to services

```dart
// domain/repositories/post_repository.dart
abstract class PostRepository {
  Future<Either<Failure, List<Post>>> fetchPosts();
}

// data/repositories/post_repository_impl.dart
class PostRepositoryImpl implements PostRepository {
  final PostDataSource _dataSource;
  
  @override
  Future<Either<Failure, List<Post>>> fetchPosts() async {
    try {
      final posts = await _dataSource.fetchPosts();
      return Right(posts);
    } catch (e) {
      return Left(ServerFailure());
    }
  }
}
```

#### 2. Service Layer Pattern

Services handle cross-cutting concerns:
- **CacheManager**: In-memory caching with TTL management
- **EnrichmentService**: Coordinate multiple repositories to enrich entities
- **ValidationService**: Complex validation logic
- **CalculationService**: Complex algorithms (salary, pension calculations)

**Location**: `data/services/` or `domain/services/` depending on dependencies

#### 3. State Management: BLoC/Cubit First (But Pragmatic)

**ê¸°ë³¸ ì›ì¹™**: Cubit/BLoC ìš°ì„ , í•˜ì§€ë§Œ ì‹¤ìš©ì ìœ¼ë¡œ íŒë‹¨

**íŒë‹¨ í”Œë¡œìš°ì°¨íŠ¸**:
```
Widgetì´ ìƒíƒœ ê´€ë¦¬ê°€ í•„ìš”í•œê°€?
â”‚
â”œâ”€ Repository/Service í˜¸ì¶œ? â†’ ğŸ”´ Cubit í•„ìˆ˜
â”œâ”€ ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§? â†’ ğŸ”´ Cubit í•„ìˆ˜
â”œâ”€ ì—¬ëŸ¬ ìƒíƒœ ì¡°í•© (loading/data/error)? â†’ ğŸ”´ Cubit í•„ìˆ˜
â”œâ”€ í…ŒìŠ¤íŠ¸ê°€ í•„ìš”í•œ ë¡œì§? â†’ ğŸ”´ Cubit í•„ìˆ˜
â”‚
â””â”€ ìˆœìˆ˜ UIë§Œ?
   â”œâ”€ ì• ë‹ˆë©”ì´ì…˜? â†’ âœ… StatefulWidget OK
   â”œâ”€ ê°„ë‹¨í•œ Form (ë¡œì»¬ë§Œ)? â†’ âœ… StatefulWidget OK
   â”œâ”€ ì¼ì‹œì  UI ìƒíƒœ? â†’ âœ… StatefulWidget OK
   â””â”€ ë³µì¡í•œ Form? â†’ ğŸŸ¡ FormCubit ê¶Œì¥
```

---

**Cubit í•„ìˆ˜ì¸ ê²½ìš°**:

**1. Repository í˜¸ì¶œ**
```dart
// ğŸ”´ Repository í˜¸ì¶œ â†’ Cubit í•„ìˆ˜
class _PostCardState extends State<PostCard> {
  late final CommunityRepository _repository; // âŒ

  Future<void> _loadComments() async {
    await _repository.fetchComments(...); // âŒ Cubitìœ¼ë¡œ!
  }
}

// âœ… Good: Cubit ì‚¬ìš©
class PostCardCubit extends Cubit<PostCardState> {
  PostCardCubit(this._repository) : super(PostCardState.initial());

  final CommunityRepository _repository;

  Future<void> loadComments(String postId) async {
    emit(state.copyWith(isLoading: true));

    final result = await _repository.fetchComments(postId);
    result.fold(
      (failure) => emit(state.copyWith(error: failure.message, isLoading: false)),
      (comments) => emit(state.copyWith(comments: comments, isLoading: false)),
    );
  }
}
```

**2. ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**
```dart
// ğŸ”´ ë³µì¡í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ â†’ Cubit í•„ìˆ˜
class _MyWidgetState extends State<MyWidget> {
  Future<void> _submit() async {
    // âŒ Widgetì— ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
    if (user.isVerified && post.isPublic && !post.isReported) {
      // Complex logic...
    }
  }
}

// âœ… Good: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ Cubitì—
class PostSubmitCubit extends Cubit<PostSubmitState> {
  Future<void> submit(Post post, User user) async {
    if (!canSubmit(post, user)) {
      emit(PostSubmitState.error('ê¶Œí•œ ì—†ìŒ'));
      return;
    }

    emit(PostSubmitState.submitting());
    // ... submit logic
  }

  bool canSubmit(Post post, User user) {
    return user.isVerified && post.isPublic && !post.isReported;
  }
}
```

**3. ì—¬ëŸ¬ ìƒíƒœ ì¡°í•©**
```dart
// ğŸ”´ loading + data + error ì¡°í•© â†’ Cubit í•„ìˆ˜
class _MyWidgetState extends State<MyWidget> {
  bool _isLoading = false;
  List<Post>? _posts;
  String? _error;

  // âŒ ìƒíƒœ ê´€ë¦¬ ë³µì¡
}

// âœ… Good: Cubitìœ¼ë¡œ ìƒíƒœ ê´€ë¦¬
class PostsCubit extends Cubit<PostsState> {
  PostsCubit(this._repository) : super(PostsState.initial());

  Future<void> fetchPosts() async {
    emit(PostsState.loading());

    final result = await _repository.fetchPosts();
    result.fold(
      (failure) => emit(PostsState.error(failure.message)),
      (posts) => emit(PostsState.loaded(posts)),
    );
  }
}
```

---

**StatefulWidgetì´ OKì¸ ê²½ìš°**:

**1. ìˆœìˆ˜ ì• ë‹ˆë©”ì´ì…˜**
```dart
// âœ… Good: ìˆœìˆ˜ ì• ë‹ˆë©”ì´ì…˜
class _LoungeMenuState extends State<LoungeMenu>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: Duration(milliseconds: 200),
    );
    _fadeAnimation = Tween<double>(begin: 0, end: 1).animate(_controller);
    _controller.forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  // Animation logic only, no business logic
}
```

**2. ë¡œì»¬ Form ìƒíƒœ (ê°„ë‹¨í•œ ê²½ìš°)**
```dart
// âœ… Good: Form ë¡œì»¬ ìƒíƒœë§Œ ê´€ë¦¬
class _QuickInputSheetState extends State<QuickInputSheet> {
  late int _currentGrade;
  late Position _position;

  @override
  void initState() {
    super.initState();
    _currentGrade = widget.initialProfile?.currentGrade ?? 35;
    _position = widget.initialProfile?.position ?? Position.teacher;
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Slider(
          value: _currentGrade.toDouble(),
          onChanged: (v) => setState(() => _currentGrade = v.toInt()),
        ),
        ElevatedButton(
          onPressed: () {
            // Callbackìœ¼ë¡œ ë¶€ëª¨ì—ê²Œ ì „ë‹¬
            widget.onSubmit(TeacherProfile(
              currentGrade: _currentGrade,
              position: _position,
            ));
          },
          child: Text('ì œì¶œ'),
        ),
      ],
    );
  }
}
// Form ê°’ë§Œ ë¡œì»¬ ê´€ë¦¬, ì œì¶œì€ ë¶€ëª¨ì—ê²Œ ìœ„ì„ â†’ OK
```

**3. ì¼ì‹œì  UI ìƒíƒœ**
```dart
// âœ… Good: ì¼ì‹œì  expand/collapse ìƒíƒœ
class _ExpandableCardState extends State<ExpandableCard> {
  bool _isExpanded = false;

  void _toggle() {
    setState(() => _isExpanded = !_isExpanded);
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: _toggle,
      child: AnimatedContainer(
        height: _isExpanded ? 200 : 80,
        // Pure UI state, no business logic
      ),
    );
  }
}
```

**4. ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœ (I/Oë§Œ)**
```dart
// âœ… Good: File I/Oë§Œ ì²˜ë¦¬
class _OptimizedImagePreviewState extends State<OptimizedImagePreview> {
  Uint8List? _imageBytes;
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadImageBytes();
  }

  Future<void> _loadImageBytes() async {
    final bytes = await widget.imageFile.readAsBytes(); // File I/O only
    if (mounted) {
      setState(() {
        _imageBytes = bytes;
        _isLoading = false;
      });
    }
  }

  // No business logic, just file loading
}
```

---

**ê²½ê³„ì„  ì¼€ì´ìŠ¤: ë³µì¡í•œ Form**

```dart
// ğŸŸ¡ ê°„ë‹¨í•œ Form â†’ StatefulWidget OK
class _SimpleFormState extends State<SimpleForm> {
  final _controller = TextEditingController();
  bool _isValid = false;

  @override
  void initState() {
    super.initState();
    _controller.addListener(() {
      setState(() => _isValid = _controller.text.length > 3);
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _submit() {
    if (_isValid) {
      widget.onSubmit(_controller.text); // Just pass to parent
    }
  }

  // Simple validation only, submit via callback â†’ OK
}

// ğŸ”´ ë³µì¡í•œ Form â†’ FormCubit ì‚¬ìš©
class CommentFormCubit extends Cubit<CommentFormState> {
  CommentFormCubit(this._repository) : super(CommentFormState.initial());

  final CommunityRepository _repository;

  Future<void> submitComment({
    required String text,
    required List<XFile> images,
  }) async {
    emit(state.copyWith(isSubmitting: true));

    // 1. Upload images
    final uploadResults = await Future.wait(
      images.map((img) => _uploadImage(img)),
    );

    // 2. Submit comment with URLs
    final result = await _repository.addComment(
      text: text,
      imageUrls: uploadResults,
    );

    result.fold(
      (failure) => emit(state.copyWith(
        error: failure.message,
        isSubmitting: false,
      )),
      (_) => emit(CommentFormState.success()),
    );
  }

  Future<String> _uploadImage(XFile image) async {
    // Image upload logic
  }
}
```

---

**ì‹¤ì œ í”„ë¡œì íŠ¸ ì˜ˆì‹œ**:

**âœ… StatefulWidget ìœ ì§€ OK**:
- `optimized_image_preview.dart` - ì´ë¯¸ì§€ ë¡œë”© ìƒíƒœë§Œ ê´€ë¦¬
- `quick_input_bottom_sheet.dart` - Form ë¡œì»¬ ìƒíƒœ, onSubmitìœ¼ë¡œ ìœ„ì„
- `lounge_floating_menu.dart` - Staggered animation ë¡œì§
- `expandable_card.dart` - ì¼ì‹œì  expand ìƒíƒœ

**ğŸš¨ Cubitìœ¼ë¡œ ì´ë™ í•„ìš”**:
- `post_card.dart` - Repository í˜¸ì¶œ, ëŒ“ê¸€ ë¡œë”©/ì œì¶œ ë¡œì§ í¬í•¨
  - í•´ê²°: PostCardCubit (ëŒ“ê¸€), ImageUploadCubit (ì´ë¯¸ì§€) ë¶„ë¦¬

---

**State Management Stack**:
- **BLoC/Cubit**: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§, ë°ì´í„° ë¡œë”©, ë³µì¡í•œ ìƒíƒœ (flutter_bloc, bloc_concurrency)
- **GetIt**: Dependency injection (manual registration)
- **GoRouter**: Navigation with authentication guards
- **StatefulWidget**: ìˆœìˆ˜ UI/Animation (ì œí•œì  ì‚¬ìš©)

### No Code Generation Policy

**âš ï¸ This project does NOT use code generation.**

**What We Use Instead**:
1. **Equatable** (instead of Freezed) for immutable entities
2. **Manual GetIt registration** (instead of Injectable) in `lib/di/di.dart`
3. **Manual serialization** (instead of json_serializable)
4. **Dio directly** (instead of Retrofit)

**Why**:
- Freezed caused build failures in calculator feature
- Generated code harder to debug
- build_runner added complexity and slow compile times

**Policy**:
- âŒ DO NOT add: freezed, json_serializable, injectable, retrofit_generator, build_runner
- âœ… Use: Equatable, manual GetIt registration, manual serialization

### Key Dependencies

**Core Firebase**: Core, Auth, Firestore, Storage, Messaging, Crashlytics

**State & Architecture**: flutter_bloc, bloc_concurrency, get_it, dartz (Either/Option), tuple, equatable

**Navigation**: go_router (manual configuration)

**HTTP**: dio, cached_network_image

**UI**: google_fonts, lottie, rive, skeletonizer, fl_chart, image_picker, file_picker, flutter_image_compress

**Error Tracking**: sentry_flutter

**Utilities**: shared_preferences, path_provider, share_plus, url_launcher, logger

**Dev Tools**: flutter_lints, very_good_analysis, bloc_test, mocktail

---

# ğŸ¤– AI Development Guidelines

The following sections are optimized for AI coding agents (Claude Code, GitHub Copilot, etc.) to make better decisions and avoid common mistakes when working on this codebase.

## Decision Trees for AI

### When to Create a New Feature Module

```
User requests new functionality
â”œâ”€ Is it a core user-facing feature? (calculator, community, auth, etc.)
â”‚  â””â”€ YES â†’ Create full feature module with domain/data/presentation
â”‚     â””â”€ Example: "Add retirement planning feature"
â”‚        â”œâ”€ lib/features/retirement_planning/domain/
â”‚        â”œâ”€ lib/features/retirement_planning/data/
â”‚        â””â”€ lib/features/retirement_planning/presentation/
â”‚
â”œâ”€ Is it a helper/utility used across features? (formatters, validators, etc.)
â”‚  â””â”€ YES â†’ Add to lib/core/ or lib/common/
â”‚     â””â”€ Example: "Add phone number formatter"
â”‚        â””â”€ lib/core/utils/phone_formatter.dart
â”‚
â””â”€ Is it feature enhancement/bug fix within existing feature?
   â””â”€ YES â†’ Modify existing feature module
      â””â”€ Example: "Add filter to community feed"
         â””â”€ Modify lib/features/community/
```

### Service vs Repository Decision

```
Need to implement data/business logic?
â”œâ”€ Single data source + CRUD operations?
â”‚  â””â”€ USE REPOSITORY
â”‚     â””â”€ Example: PostRepository.fetchPosts() â†’ Firestore query
â”‚
â”œâ”€ Multiple repositories coordination?
â”‚  â””â”€ USE SERVICE (EnrichmentService pattern)
â”‚     â””â”€ Example: PostEnrichmentService coordinates:
â”‚        - PostRepository (fetch posts)
â”‚        - InteractionRepository (fetch likes/bookmarks)
â”‚        - CommentRepository (fetch top comments)
â”‚        - CacheManager (check cache)
â”‚
â”œâ”€ In-memory caching with TTL?
â”‚  â””â”€ USE SERVICE (CacheManager pattern)
â”‚     â””â”€ Example: InteractionCacheManager
â”‚        - Manages cache lifecycle
â”‚        - TTL tracking
â”‚        - Hit/miss statistics
â”‚
â”œâ”€ Complex calculations without external data?
â”‚  â””â”€ USE SERVICE (CalculationService pattern)
â”‚     â””â”€ Example: SalaryCalculationService
â”‚        - Grade calculation
â”‚        - Allowance computation
â”‚        - Tax deduction
â”‚
â””â”€ Complex validation logic?
   â””â”€ USE SERVICE (ValidationService pattern)
      â””â”€ Example: PaystubValidationService
         - OCR result validation
         - Career track detection
         - Format verification
```

### Cubit vs BLoC Decision

```
Need state management?
â”œâ”€ Simple state with 1-3 methods?
â”‚  â””â”€ USE CUBIT
â”‚     â””â”€ Example: ThemeCubit (toggleTheme)
â”‚
â”œâ”€ Complex state with events and event transformers?
â”‚  â””â”€ USE BLOC (rare in this project)
â”‚     â””â”€ Example: SearchBloc with debounce
â”‚
â”œâ”€ Form handling?
â”‚  â””â”€ USE CUBIT (always)
â”‚     â””â”€ Example: CommentFormCubit
â”‚
â””â”€ API calls and data loading?
   â””â”€ USE CUBIT (default choice)
      â””â”€ Example: CommunityCubit
```

### When to Extract Widgets

```
Widget file size check:
â”œâ”€ 5+ private widgets in single file?
â”‚  â””â”€ EXTRACT IMMEDIATELY
â”‚     â””â”€ Create widgets/[feature_name]/[concern].dart
â”‚        â””â”€ Example: post_card.dart (885 lines)
â”‚           - Extract to widgets/post/comment_section.dart
â”‚           - Extract to widgets/post/like_button.dart
â”‚           - Extract to widgets/post/share_handler.dart
â”‚
â”œâ”€ Complex widget with 400+ lines?
â”‚  â””â”€ REVIEW FOR EXTRACTION
â”‚     â””â”€ Check if single responsibility
â”‚        - If multiple concerns â†’ Split by concern
â”‚        - If single concern â†’ Keep together (may be acceptable)
â”‚
â””â”€ Widget reused in 2+ places?
   â””â”€ EXTRACT TO common/ OR widgets/
      â””â”€ Example: LoadingButton used everywhere
         â””â”€ lib/common/widgets/loading_button.dart
```

## GongMuTalk Domain Knowledge

### Korean Public Servant Salary System

**Core Concepts AI Must Understand**:

```dart
// Grade System (í˜¸ë´‰)
// - Determines base salary
// - Increases annually (usually)
// - Range: 1-40+ depending on career track
int grade = 15; // 15í˜¸ë´‰

// Career Track (ì§ë ¬)
// - Determines job category and salary table
// - Examples: êµìœ¡ê³µë¬´ì›(educators), ì†Œë°©(firefighters), ì„¸ë¬´(tax officials)
String careerTrack = 'êµìœ¡ê³µë¬´ì›';

// Allowances (ìˆ˜ë‹¹)
// - Multiple types: family, meal, commute, regional, etc.
// - Different rules per career track
Map<String, int> allowances = {
  'family': 100000,  // ê°€ì¡±ìˆ˜ë‹¹
  'meal': 130000,    // ì‹ë¹„
  'commute': 50000,  // êµí†µë¹„
  'position': 200000, // ì§ê¸‰ë³´ì¡°ë¹„
};

// Tax Deductions (ì„¸ê¸ˆ)
// - National tax (êµ­ì„¸)
// - Local tax (ì§€ë°©ì„¸)
// - National pension (êµ­ë¯¼ì—°ê¸ˆ)
// - Health insurance (ê±´ê°•ë³´í—˜)
// - Employment insurance (ê³ ìš©ë³´í—˜)
```

**Salary Calculation Flow**:
```
1. Determine base salary from grade + career track table
2. Add all applicable allowances
3. Calculate gross salary
4. Deduct taxes (progressive rates)
5. Deduct social insurance
6. Result = net salary (ì‹¤ìˆ˜ë ¹ì•¡)
```

### Career Track Verification System

**How Paystub OCR Works**:

```
User uploads paystub image/PDF
â”œâ”€ 1. Vision API extracts text
â”‚     â””â”€ Returns raw OCR text
â”‚
â”œâ”€ 2. Career track detection
â”‚     â””â”€ Match keywords in text:
â”‚        - "êµìœ¡ê³µë¬´ì›" â†’ Elementary/Middle/High School Teacher
â”‚        - "ì†Œë°©" â†’ Firefighter
â”‚        - "ì„¸ë¬´" â†’ Tax Official
â”‚        - "ê²½ì°°" â†’ Police Officer
â”‚        â””â”€ Use massive keyword mapping (functions/src/paystubVerification.ts)
â”‚
â”œâ”€ 3. Salary verification
â”‚     â””â”€ Extract numeric values
â”‚        - Base salary matches grade?
â”‚        - Allowances reasonable?
â”‚
â””â”€ 4. Update user profile
      â””â”€ Set career track
      â””â”€ Mark as verified
      â””â”€ Grant lounge access
```

**Important**: If you modify career verification, understand that it affects:
- User authentication level
- Lounge access permissions
- Community visibility
- Salary calculator accuracy

### Lounge Hierarchy System

**Structure**:
```
Lounges (ë¼ìš´ì§€)
â”œâ”€ Root Lounges (ì§ë ¬ ë¼ìš´ì§€)
â”‚  â”œâ”€ êµìœ¡ê³µë¬´ì› (Educators)
â”‚  â”œâ”€ ì†Œë°©ê³µë¬´ì› (Firefighters)
â”‚  â”œâ”€ ì„¸ë¬´ê³µë¬´ì› (Tax Officials)
â”‚  â””â”€ ...
â”‚
â””â”€ Sub-Lounges (ì„¸ë¶€ ì§ë ¬ ë¼ìš´ì§€)
   â””â”€ êµìœ¡ê³µë¬´ì›
      â”œâ”€ ì´ˆë“±êµì‚¬ (Elementary Teachers)
      â”œâ”€ ì¤‘ë“±êµì‚¬ (Middle School Teachers)
      â”œâ”€ ê³ ë“±êµì‚¬ (High School Teachers)
      â””â”€ êµìœ¡ì „ë¬¸ì§ (Education Specialists)
```

**Access Rules**:
- Unverified users: See only public posts
- Verified users: Access their career track lounge + sub-lounges
- Posts in lounges are semi-anonymous (position shown, not full name)

**When Building Lounge Features**:
- Always check user verification status
- Filter posts by lounge membership
- Respect hierarchy (sub-lounge users can see parent lounge)
- Handle anonymous/semi-anonymous display logic

### Semi-Anonymous System

**Key Concept**: Users are authenticated but displayed semi-anonymously

```dart
// Real user data
User {
  uid: "abc123",
  name: "ê¹€ì² ìˆ˜",
  careerTrack: "êµìœ¡ê³µë¬´ì›",
  position: "ì´ˆë“±êµì‚¬",
  verified: true,
}

// Displayed in community
Post {
  author: "ì´ˆë“±êµì‚¬ 5ë…„ì°¨", // Position + years, NO name
  content: "...",
  lounge: "êµìœ¡ê³µë¬´ì›/ì´ˆë“±êµì‚¬",
}
```

**Privacy Protection Rules**:
- âœ… Show: Career track, position, years of service
- âŒ Hide: Name, specific workplace, exact location
- âœ… Show only in lounge: Detailed career info
- âŒ Never show publicly: Contact info, government ID

## Common Patterns & Anti-Patterns

### âœ… DO: Use Either Pattern for Error Handling

```dart
// âœ… Good: Repository returns Either
Future<Either<Failure, List<Post>>> fetchPosts() async {
  try {
    final posts = await _dataSource.fetchPosts();
    return Right(posts);
  } on ServerException {
    return Left(ServerFailure());
  } on NetworkException {
    return Left(NetworkFailure());
  } catch (e) {
    return Left(UnknownFailure());
  }
}

// âœ… Good: Cubit handles Either
Future<void> loadPosts() async {
  emit(CommunityState.loading());

  final result = await _repository.fetchPosts();
  result.fold(
    (failure) => emit(CommunityState.error(failure.message)),
    (posts) => emit(CommunityState.loaded(posts)),
  );
}

// âŒ Bad: Throwing exceptions directly
Future<List<Post>> fetchPosts() async {
  final posts = await _dataSource.fetchPosts(); // Throws!
  return posts; // Caller has no type-safe error handling
}
```

### âœ… DO: Manual GetIt Registration

```dart
// âœ… Good: Manual registration in lib/di/di.dart
final GetIt getIt = GetIt.instance;

Future<void> configureDependencies() async {
  // Repositories (singletons)
  getIt.registerLazySingleton<CommunityRepository>(
    () => CommunityRepository(
      postDataSource: getIt(),
      cacheManager: getIt(),
      enrichmentService: getIt(),
    ),
  );

  // Cubits (factories - new instance each time)
  getIt.registerFactory<CommunityCubit>(
    () => CommunityCubit(repository: getIt()),
  );
}

// âŒ Bad: Using Injectable or any code generation
@module
abstract class AppModule {
  @lazySingleton
  CommunityRepository get repository; // DON'T DO THIS
}
```

### âœ… DO: Use Equatable for Entities

```dart
// âœ… Good: Equatable for value equality
class Post extends Equatable {
  const Post({
    required this.id,
    required this.title,
    required this.content,
  });

  final String id;
  final String title;
  final String content;

  @override
  List<Object?> get props => [id, title, content];

  Post copyWith({
    String? id,
    String? title,
    String? content,
  }) {
    return Post(
      id: id ?? this.id,
      title: title ?? this.title,
      content: content ?? this.content,
    );
  }
}

// âŒ Bad: Using Freezed
@freezed
class Post with _$Post {
  const factory Post({
    required String id,
    required String title,
  }) = _Post;
} // DON'T DO THIS - project policy prohibits code generation
```

### âœ… DO: Cache Expensive Firestore Queries

```dart
// âœ… Good: Cache with TTL
class InteractionCacheManager {
  static const Duration _cacheTTL = Duration(minutes: 10);
  DateTime? _lastUpdate;
  Set<String>? _cachedLikedPostIds;

  Future<Set<String>> getLikedPostIds(String uid) async {
    if (_shouldRefresh()) {
      _cachedLikedPostIds = await _fetchFromFirestore(uid);
      _lastUpdate = DateTime.now();
    }
    return _cachedLikedPostIds!;
  }

  bool _shouldRefresh() {
    if (_lastUpdate == null) return true;
    return DateTime.now().difference(_lastUpdate!) > _cacheTTL;
  }
}

// âŒ Bad: Always query Firestore
Future<Set<String>> getLikedPostIds(String uid) async {
  return await _fetchFromFirestore(uid); // Expensive every time!
}
```

### âœ… DO: Pagination with Limit

```dart
// âœ… Good: Paginated queries
Future<List<Post>> fetchPosts({required int limit, DocumentSnapshot? lastDoc}) async {
  var query = _firestore
    .collection('posts')
    .orderBy('createdAt', descending: true)
    .limit(limit);

  if (lastDoc != null) {
    query = query.startAfterDocument(lastDoc);
  }

  final snapshot = await query.get();
  return snapshot.docs.map((doc) => Post.fromJson(doc.data())).toList();
}

// âŒ Bad: Fetching all documents
Future<List<Post>> fetchPosts() async {
  final snapshot = await _firestore.collection('posts').get(); // Gets ALL!
  return snapshot.docs.map((doc) => Post.fromJson(doc.data())).toList();
}
```

### âœ… DO: Dispose Resources

```dart
// âœ… Good: Proper disposal
class _MyWidgetState extends State<MyWidget> {
  late StreamSubscription _subscription;
  late AnimationController _animController;
  late TextEditingController _textController;
  Timer? _debounceTimer;

  @override
  void dispose() {
    _subscription.cancel();
    _animController.dispose();
    _textController.dispose();
    _debounceTimer?.cancel();
    super.dispose();
  }
}

// âŒ Bad: Memory leaks
class _MyWidgetState extends State<MyWidget> {
  late StreamSubscription _subscription;
  // ... other resources

  @override
  void dispose() {
    super.dispose(); // Forgot to dispose resources!
  }
}
```

### âœ… DO: Use BLoC/Cubit, Not StatefulWidget for Logic

```dart
// âœ… Good: Business logic in Cubit
class CommentFormCubit extends Cubit<CommentFormState> {
  CommentFormCubit(this._repository) : super(CommentFormState.initial());

  final CommunityRepository _repository;

  void updateText(String text) {
    emit(state.copyWith(text: text));
  }

  Future<void> submitComment(String postId) async {
    emit(state.copyWith(isSubmitting: true));
    final result = await _repository.addComment(postId, state.text);
    result.fold(
      (failure) => emit(state.copyWith(error: failure.message, isSubmitting: false)),
      (_) => emit(CommentFormState.success()),
    );
  }
}

// âŒ Bad: Business logic in StatefulWidget
class _CommentFormState extends State<CommentForm> {
  final _controller = TextEditingController();
  bool _isSubmitting = false;

  Future<void> _submit() async {
    setState(() => _isSubmitting = true);
    try {
      await repository.addComment(widget.postId, _controller.text); // Hard to test!
    } catch (e) {
      // Error handling mixed with UI
    }
  }
}
```

### âŒ DON'T: Use Code Generation

```dart
// âŒ Bad: Freezed, Injectable, json_serializable
import 'package:freezed_annotation/freezed_annotation.dart';

part 'post.freezed.dart';
part 'post.g.dart';

@freezed
class Post with _$Post {
  factory Post.fromJson(Map<String, dynamic> json) => _$PostFromJson(json);
} // DON'T DO THIS

// âœ… Good: Manual serialization with Equatable
class Post extends Equatable {
  const Post({required this.id, required this.title});

  final String id;
  final String title;

  factory Post.fromJson(Map<String, dynamic> json) => Post(
    id: json['id'] as String,
    title: json['title'] as String,
  );

  Map<String, dynamic> toJson() => {'id': id, 'title': title};

  @override
  List<Object?> get props => [id, title];
}
```

### âŒ DON'T: N+1 Query Loops

```dart
// âŒ Bad: N+1 queries (expensive!)
Future<List<Post>> enrichPostsWithAuthor(List<Post> posts) async {
  final enrichedPosts = <Post>[];
  for (final post in posts) {
    final author = await _firestore.collection('users').doc(post.authorId).get(); // N queries!
    enrichedPosts.add(post.copyWith(author: author));
  }
  return enrichedPosts;
}

// âœ… Good: Batch query with whereIn
Future<List<Post>> enrichPostsWithAuthor(List<Post> posts) async {
  final authorIds = posts.map((p) => p.authorId).toSet().toList();

  // Firestore whereIn supports max 10 items per query
  final authors = <String, User>{};
  for (var i = 0; i < authorIds.length; i += 10) {
    final batch = authorIds.skip(i).take(10).toList();
    final snapshot = await _firestore
      .collection('users')
      .where(FieldPath.documentId, whereIn: batch)
      .get();

    for (final doc in snapshot.docs) {
      authors[doc.id] = User.fromJson(doc.data());
    }
  }

  return posts.map((post) => post.copyWith(author: authors[post.authorId])).toList();
}
```

## AI Workflow Optimization

### Which Files to Read for Different Contexts

**Context: Adding a new field to existing feature**

Priority read order:
1. `lib/features/[feature]/domain/entities/[entity].dart` - Check entity structure
2. `lib/features/[feature]/data/models/[model].dart` - Update model serialization
3. `lib/features/[feature]/presentation/cubit/[feature]_cubit.dart` - Update state if needed
4. `lib/features/[feature]/presentation/views/[feature]_page.dart` - Display new field

**Context: Fixing a bug in community feed**

Priority read order:
1. `lib/features/community/presentation/cubit/community_cubit.dart` - Check state logic
2. `lib/features/community/data/community_repository.dart` - Check data fetching
3. `lib/features/community/data/services/post_enrichment_service.dart` - Check enrichment logic
4. `lib/features/community/data/services/interaction_cache_manager.dart` - Check caching
5. `lib/features/community/presentation/widgets/post_card.dart` - Check UI rendering

**Context: Implementing a new calculator feature**

Priority read order:
1. `lib/features/calculator/` - Study existing calculator structure
2. `lib/features/calculator/domain/usecases/` - Understand calculation patterns
3. `lib/features/pension/` - Similar pattern (pension calculator)
4. `lib/core/utils/number_formatter.dart` - Existing number utilities
5. `CLAUDE.md` - Review calculation service pattern

**Context: Adding Firebase function**

Priority read order:
1. `functions/src/index.ts` - Function exports
2. `functions/src/[similar-function].ts` - Study similar function
3. `CLAUDE.md` - Review Firebase Functions section
4. `functions/package.json` - Available dependencies

**Context: Debugging authentication issue**

Priority read order:
1. `lib/features/auth/presentation/cubit/auth_cubit.dart` - Auth state management
2. `lib/features/auth/data/repositories/auth_repository.dart` - Auth repository
3. `lib/core/firebase/firebase_config.dart` - Firebase setup
4. `lib/routing/app_router.dart` - Navigation guards
5. `test/features/auth/data/auth_user_session_test.dart` - Existing auth tests

**Context: Optimizing performance**

Priority read order:
1. `CLAUDE.md` - Performance & Cost Optimization section
2. `lib/features/community/data/services/interaction_cache_manager.dart` - Caching example
3. `lib/core/utils/image_compression_util.dart` - Image optimization example
4. Large repository files (check for optimization opportunities)

### Reading Strategy by File Size

- **<200 lines**: Read entire file
- **200-500 lines**: Read class signatures, then specific methods as needed
- **500-800 lines**: Read file structure first, then targeted sections
- **800+ lines**: File should be refactored, but if reading: focus on specific methods/classes only

## Naming Conventions

### File Naming

```dart
// âœ… Good: Lowercase with underscores
post_repository.dart
interaction_cache_manager.dart
community_cubit.dart
post_enrichment_service.dart
salary_calculator_page.dart

// âŒ Bad: CamelCase, hyphens, or other formats
PostRepository.dart
interaction-cache-manager.dart
communityCubit.dart
```

### Class Naming

```dart
// âœ… Good: PascalCase, descriptive
class CommunityRepository { }
class PostEnrichmentService { }
class InteractionCacheManager { }
class CommunityCubit extends Cubit<CommunityState> { }

// âŒ Bad: Abbreviations, unclear names
class CommRepo { }  // Too abbreviated
class Service { }   // Too generic
class Manager { }   // What does it manage?
```

### Variable Naming

```dart
// âœ… Good: camelCase, descriptive
final communityRepository = getIt<CommunityRepository>();
final likedPostIds = await cacheManager.getLikedPostIds(uid);
final isSubmitting = state.isSubmitting;

// âŒ Bad: Abbreviations, unclear
final repo = getIt<CommunityRepository>();
final ids = await cacheManager.getLikedPostIds(uid);
final flag = state.isSubmitting;
```

### Method Naming

```dart
// âœ… Good: Verb phrases, clear intent
Future<Either<Failure, List<Post>>> fetchPosts();
Future<void> likePost(String postId);
Future<void> clearCache({String? uid});
bool shouldRefreshCache();

// âŒ Bad: Ambiguous or noun-only
Future<Either<Failure, List<Post>>> posts();  // Noun only
Future<void> post(String postId);  // What does this do?
Future<void> cache();  // Clear? Update? Fetch?
```

### State Class Naming

```dart
// âœ… Good: Feature + State
class CommunityState extends Equatable { }
class AuthState extends Equatable { }
class ProfileState extends Equatable { }

// For state variants
class CommunityState {
  const CommunityState.initial();
  const CommunityState.loading();
  const CommunityState.loaded(this.posts);
  const CommunityState.error(this.message);
}

// âŒ Bad: Generic or unclear
class State { }  // Too generic
class Data { }   // Not descriptive
```

### Service/Manager Naming Patterns

```dart
// âœ… Good: Suffix indicates purpose
InteractionCacheManager     // Manages cache
PostEnrichmentService       // Enriches posts
SalaryCalculationService    // Calculates salary
PaystubValidationService    // Validates paystub

// âŒ Bad: Inconsistent or unclear suffixes
InteractionHelper           // Helper is too vague
PostService                 // Service does what?
SalaryUtils                 // Utils is too generic
```

### Cubit Method Naming Patterns

```dart
// âœ… Good: Action verbs
class CommunityCubit extends Cubit<CommunityState> {
  Future<void> fetchPosts() async { }
  Future<void> likePost(String postId) async { }
  Future<void> unlikePost(String postId) async { }
  Future<void> refreshFeed() async { }
  void clearError() { }
}

// âŒ Bad: Ambiguous names
class CommunityCubit extends Cubit<CommunityState> {
  Future<void> load() async { }        // Load what?
  Future<void> update(String id) async { }  // Update what? How?
  Future<void> handle() async { }      // Handle what?
}
```

## AI Testing Checklist

### When Creating a Repository

**Must Test**:
- âœ… Successful data fetch returns `Right(data)`
- âœ… Network error returns `Left(NetworkFailure())`
- âœ… Server error returns `Left(ServerFailure())`
- âœ… Data source called with correct parameters
- âœ… Error handling for each external call

**Example**:
```dart
test('should return Right(posts) when fetch succeeds', () async {
  when(() => dataSource.fetchPosts()).thenAnswer((_) async => [mockPost]);

  final result = await repository.fetchPosts();

  expect(result, Right([mockPost]));
  verify(() => dataSource.fetchPosts()).called(1);
});

test('should return Left(ServerFailure) when data source throws', () async {
  when(() => dataSource.fetchPosts()).thenThrow(ServerException());

  final result = await repository.fetchPosts();

  expect(result, Left(ServerFailure()));
});
```

### When Creating a Service (CacheManager, EnrichmentService, etc.)

**Must Test**:
- âœ… Cache hit returns cached data without external calls
- âœ… Cache miss triggers data fetch
- âœ… TTL expiration triggers refresh
- âœ… Cache statistics tracking (if applicable)
- âœ… Service coordinates multiple repositories correctly

**Example**:
```dart
test('should return cached data when cache is fresh', () {
  cacheManager.updateCache(uid: 'user1', likedIds: {'post1'});

  expect(cacheManager.shouldRefreshCache(), isFalse);
  expect(cacheManager.getLikedPostIds('user1'), {'post1'});
});

test('should refresh cache after TTL expiration', () async {
  cacheManager.updateCache(uid: 'user1', likedIds: {'post1'});

  // Simulate time passage (mock DateTime or use fake_async)
  await Future.delayed(Duration(minutes: 11));

  expect(cacheManager.shouldRefreshCache(), isTrue);
});
```

### When Creating a Cubit

**Must Test**:
- âœ… Initial state is correct
- âœ… State transitions for success case
- âœ… State transitions for error case
- âœ… State transitions for loading case
- âœ… Repository called with correct parameters

**Example** (using bloc_test):
```dart
blocTest<CommunityCubit, CommunityState>(
  'emits [loading, loaded] when fetchPosts succeeds',
  build: () {
    when(() => repository.fetchPosts()).thenAnswer(
      (_) async => Right([mockPost]),
    );
    return CommunityCubit(repository);
  },
  act: (cubit) => cubit.fetchPosts(),
  expect: () => [
    CommunityState.loading(),
    CommunityState.loaded(posts: [mockPost]),
  ],
  verify: (_) {
    verify(() => repository.fetchPosts()).called(1);
  },
);

blocTest<CommunityCubit, CommunityState>(
  'emits [loading, error] when fetchPosts fails',
  build: () {
    when(() => repository.fetchPosts()).thenAnswer(
      (_) async => Left(ServerFailure()),
    );
    return CommunityCubit(repository);
  },
  act: (cubit) => cubit.fetchPosts(),
  expect: () => [
    CommunityState.loading(),
    CommunityState.error(message: 'Server error'),
  ],
);
```

### When Creating a Widget

**Test if**:
- Widget is complex (400+ lines)
- Widget has conditional rendering logic
- Widget handles user interactions
- Widget is reused in multiple places

**Must Test** (if testing):
- âœ… Widget renders without errors
- âœ… Conditional branches render correctly
- âœ… User interactions trigger expected callbacks
- âœ… Edge cases (null data, empty lists, errors)

**Example**:
```dart
testWidgets('should display post content', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: PostCard(post: mockPost),
    ),
  );

  expect(find.text(mockPost.title), findsOneWidget);
  expect(find.text(mockPost.content), findsOneWidget);
});

testWidgets('should call onLike when like button tapped', (tester) async {
  var likeCalled = false;

  await tester.pumpWidget(
    MaterialApp(
      home: PostCard(
        post: mockPost,
        onLike: () => likeCalled = true,
      ),
    ),
  );

  await tester.tap(find.byIcon(Icons.favorite_border));
  expect(likeCalled, isTrue);
});
```

### Coverage Requirements Summary

When implementing new features, ensure:

- âœ… **Domain layer**: 80%+ coverage (entities, usecases)
- âœ… **Services**: 70%+ coverage (cache managers, enrichment services)
- âœ… **Repositories**: 60%+ coverage (data layer)
- âœ… **Cubits**: 50%+ coverage (state management)
- âš ï¸ **Widgets**: Test complex widgets only (optional, <50% is acceptable)

**Before submitting PR**:
```bash
flutter test --coverage
genhtml coverage/lcov.info -o coverage/html
open coverage/html/index.html  # Check coverage report
```

Ensure new code meets minimum 50% coverage before merge.

---

# ğŸ”š End of AI Development Guidelines

---

## Code Quality & Standards

### File Size Guidelines

**Philosophy**: "Single Responsibility > File Size"

íŒŒì¼ í¬ê¸°ëŠ” **ë‹¨ì¼ ì±…ì„ ì›ì¹™**ì„ ìœ„í•œ ì§€í‘œì´ì§€, ì ˆëŒ€ì  ê¸°ì¤€ì´ ì•„ë‹™ë‹ˆë‹¤.
ì¤„ ìˆ˜ë³´ë‹¤ "ì´ íŒŒì¼ì´ í•˜ë‚˜ì˜ ëª…í™•í•œ ì±…ì„ë§Œ ê°€ì§€ëŠ”ê°€?"ê°€ ë” ì¤‘ìš”í•©ë‹ˆë‹¤.

**Zone ê¸°ì¤€** (ì°¸ê³ ìš©, ì ˆëŒ€ì  ì•„ë‹˜):

**UI Files** (views/, widgets/):
- âœ… Green: 0-400 lines (ì´ìƒì )
- âš ï¸ Yellow: 400-600 lines â†’ **ë‹¨ì¼ ì±…ì„ ê²€í†  í•„ìš”**
- ğŸ”¶ Orange: 600-800 lines â†’ **ì—¬ëŸ¬ ì±…ì„ í˜¼ì¬ ê°€ëŠ¥ì„± ë†’ìŒ**
- ğŸš¨ Red: 800+ lines â†’ **ê±°ì˜ í™•ì‹¤íˆ ì—¬ëŸ¬ ì±…ì„ ì„ì„**

**Logic Files** (cubit/, repositories/, services/):
- âœ… Green: 0-300 lines (ì´ìƒì )
- âš ï¸ Yellow: 300-500 lines â†’ **ë‹¨ì¼ ë„ë©”ì¸ì¸ì§€ í™•ì¸**
- ğŸ”¶ Orange: 500-700 lines â†’ **ë„ë©”ì¸ ë¡œì§ ë¶„ë¦¬ ê²€í† **
- ğŸš¨ Red: 700+ lines â†’ **í™•ì‹¤íˆ ë¶„ë¦¬ í•„ìš”**

**Domain Files** (entities/, models/, constants/):
- âœ… Green: 0-200 lines (ì´ìƒì )
- âš ï¸ Yellow: 200-400 lines
- ğŸ”¶ Orange: 400-600 lines â†’ **ìƒìˆ˜ ë°ì´í„°ë©´ JSON ì´ë™ ê³ ë ¤**
- ğŸš¨ Red: 600+ lines â†’ **ë°ì´í„°ì™€ ë¡œì§ ë¶„ë¦¬ í•„ìš”**

---

**ë¶„ë¦¬ íŒë‹¨ ê¸°ì¤€** (ìš°ì„ ìˆœìœ„ ìˆœ):

**1. âœ… ì—¬ëŸ¬ ì±…ì„ì´ ì„ì˜€ëŠ”ê°€?** â†’ ì¦‰ì‹œ ë¶„ë¦¬

```dart
// âŒ Bad: PostCardê°€ ëŒ“ê¸€ ê´€ë¦¬ + ì´ë¯¸ì§€ ì—…ë¡œë“œ + ê³µìœ  + ë©”ë‰´
class _PostCardState extends State<PostCard> {
  late final CommunityRepository _repository;

  Future<void> _loadComments() { } // ì±…ì„ 1: ëŒ“ê¸€
  Future<void> _uploadImage() { }  // ì±…ì„ 2: ì´ë¯¸ì§€
  Future<void> _sharePost() { }    // ì±…ì„ 3: ê³µìœ 
  void _showMenu() { }             // ì±…ì„ 4: ë©”ë‰´
}

// âœ… Good: ê°ê° ë¶„ë¦¬
- PostCard (ë ˆì´ì•„ì›ƒ ì¡°ë¦½ë§Œ)
- PostCommentsCubit (ëŒ“ê¸€ ë¡œì§)
- ImageUploadCubit (ì´ë¯¸ì§€ ë¡œì§)
- ShareHandler (ê³µìœ  ë¡œì§)
- MenuOverlay (ë©”ë‰´ í‘œì‹œ)
```

**2. âš ï¸ 5+ private widgets/methods?** â†’ ë¶„ë¦¬ ê³ ë ¤

```dart
// âŒ 5ê°œ ì´ìƒì˜ private ìœ„ì ¯ â†’ ë³„ë„ íŒŒì¼ë¡œ
class _MyWidgetState extends State<MyWidget> {
  Widget _buildHeader() { }
  Widget _buildContent() { }
  Widget _buildFooter() { }
  Widget _buildActionBar() { }
  Widget _buildMenu() { }  // 5ê°œ!
  Widget _buildComments() { }  // 6ê°œ!
}

// âœ… Good: ê°ê° ìœ„ì ¯ íŒŒì¼ë¡œ ë¶„ë¦¬
- HeaderWidget (header.dart)
- ContentWidget (content.dart)
- FooterWidget (footer.dart)
- ActionBar (action_bar.dart)
- MenuWidget (menu.dart)
- CommentsSection (comments_section.dart)
```

**3. âš ï¸ ë³µì¡í•œ ë‹¨ì¼ ì±…ì„ì¸ê°€?** â†’ ìœ ì§€ OK

```dart
// âœ… OK: ë³µì¡í•˜ì§€ë§Œ "Staggered Animation"ì´ë¼ëŠ” ë‹¨ì¼ ì±…ì„
class _LoungeFloatingMenuState extends State<LoungeFloatingMenu>
    with TickerProviderStateMixin {
  late AnimationController _controller;
  List<AnimationController> _itemControllers;
  List<Animation<Offset>> _slideAnimations;
  List<Animation<double>> _fadeAnimations;

  // 600ì¤„ì´ì§€ë§Œ ëª¨ë‘ ì• ë‹ˆë©”ì´ì…˜ ë¡œì§
  void _initializeItemAnimations() { }
  void _startStaggeredAnimation() { }
  void _reverseAnimation() { }
  // ... all animation-related
}
// íŒì •: ë‹¨ì¼ ì±…ì„ (Staggered Menu Animation) â†’ ìœ ì§€ OK
```

**4. âš ï¸ ìƒìˆ˜ ë°ì´í„°ê°€ ëŒ€ë¶€ë¶„ì¸ê°€?** â†’ JSON/ì™¸ë¶€ íŒŒì¼ë¡œ ì´ë™

```dart
// âŒ Bad: 949ì¤„ì˜ ìƒìˆ˜ ë°ì´í„°
class LoungeDefinitions {
  static const List<Lounge> defaultLounges = [
    Lounge(id: 'teacher', name: 'êµì‚¬', ...),
    Lounge(id: 'firefighter', name: 'ì†Œë°©', ...),
    // ... 949 lines of data
  ];
}

// âœ… Good: JSONìœ¼ë¡œ ì´ë™
// assets/data/lounges.json (ë°ì´í„°)
[
  {"id": "teacher", "name": "êµì‚¬", ...},
  {"id": "firefighter", "name": "ì†Œë°©", ...}
]

// lib/.../lounge_loader.dart (50ì¤„, ë¡œë”© ë¡œì§ë§Œ)
class LoungeLoader {
  Future<List<Lounge>> loadLounges() async {
    final json = await rootBundle.loadString('assets/data/lounges.json');
    return (jsonDecode(json) as List).map((e) => Lounge.fromJson(e)).toList();
  }
}
```

---

**ìœ ì§€ ê°€ëŠ¥í•œ ì˜ˆì™¸** (ë‹¨ì¼ ì±…ì„ì´ë©´ í° íŒŒì¼ë„ OK):

**âœ… ë³µì¡í•œ ì• ë‹ˆë©”ì´ì…˜ ìœ„ì ¯: 600ì¤„ê¹Œì§€ OK**
```dart
// ì˜ˆ: Staggered animation with multiple controllers
class _ComplexAnimationState extends State<ComplexAnimation>
    with TickerProviderStateMixin {
  // 10+ AnimationControllers
  // Staggered timing logic
  // Coordinate multiple animations
  // ë‹¨ì¼ ì±…ì„: "Complex coordinated animation"
}
```

**âœ… Cubit with ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬: 500ì¤„ê¹Œì§€ OK**
```dart
// ì˜ˆ: Feed pagination + filtering + sorting + caching
class CommunityFeedCubit extends Cubit<CommunityFeedState> {
  // loadInitial() - pagination logic
  // loadMore() - infinite scroll
  // applyFilter() - filtering
  // changeSort() - sorting
  // _refreshCache() - caching
  // ë‹¨ì¼ ì±…ì„: "Feed state management"
}
```

**âœ… ë‹¤ë‹¨ê³„ Form ë¡œì§: 400ì¤„ê¹Œì§€ OK**
```dart
// ì˜ˆ: Multi-step wizard with validation
class _MultiStepFormState extends State<MultiStepForm> {
  // Step 1, 2, 3 UI
  // Validation for each step
  // Navigation between steps
  // Final submission
  // ë‹¨ì¼ ì±…ì„: "Multi-step form flow"
}
```

**ì¡°ê±´**:
- ì •ë§ë¡œ **ë‹¨ì¼ ì±…ì„**ë§Œ ê°€ì ¸ì•¼ í•¨
- ì£¼ì„ìœ¼ë¡œ ì„¹ì…˜ì´ ëª…í™•íˆ êµ¬ë¶„ë˜ì–´ì•¼ í•¨
- íŒŒì¼ ìƒë‹¨ì— ì±…ì„ ëª…ì‹œ

---

**ì‹¤ì œ í”„ë¡œì íŠ¸ ì˜ˆì‹œ**:

**âœ… ìœ ì§€ OK**:
- `lounge_floating_menu.dart` (592ì¤„) - ë³µì¡í•œ staggered animation ë¡œì§
  - ë‹¨ì¼ ì±…ì„: "Lounge menu with staggered animations"
- `community_feed_cubit.dart` (501ì¤„) - í”¼ë“œ ìƒíƒœ ê´€ë¦¬ (í˜ì´ì§€ë„¤ì´ì…˜ + í•„í„° + ì •ë ¬)
  - ë‹¨ì¼ ì±…ì„: "Community feed state management"
- `auth_cubit.dart` (496ì¤„) - ì¸ì¦ ìƒíƒœ ê´€ë¦¬ (ë¡œê·¸ì¸ + í”„ë¡œí•„ + ì„¸ì…˜)
  - ë‹¨ì¼ ì±…ì„: "Authentication state management"

**ğŸš¨ ë¦¬íŒ©í† ë§ í•„ìš”**:
- `post_card.dart` (860ì¤„) - ì—¬ëŸ¬ ì±…ì„ ì„ì„
  - ë¬¸ì œ: ëŒ“ê¸€ ê´€ë¦¬ + ì´ë¯¸ì§€ ì—…ë¡œë“œ + ê³µìœ  + ë©”ë‰´ + ì¢‹ì•„ìš”/ë¶ë§ˆí¬
  - í•´ê²°: PostCardCubit (ëŒ“ê¸€), ImageUploadCubit (ì´ë¯¸ì§€), ShareHandler (ê³µìœ ) ë¶„ë¦¬
- `lounge_definitions.dart` (949ì¤„) - ìƒìˆ˜ ë°ì´í„°
  - ë¬¸ì œ: ì½”ë“œ íŒŒì¼ì— ë°ì´í„°ë§Œ 949ì¤„
  - í•´ê²°: assets/data/lounges.json ì´ë™ + LoungeLoader (50ì¤„)

---

**AI ì—ì´ì „íŠ¸ë¥¼ ìœ„í•œ ì²´í¬ë¦¬ìŠ¤íŠ¸**:

íŒŒì¼ ì‘ì„±/ìˆ˜ì • ì‹œ ë‹¤ìŒì„ í™•ì¸í•˜ì„¸ìš”:

```
1. ì´ íŒŒì¼ì˜ ë‹¨ì¼ ì±…ì„ì€ ë¬´ì—‡ì¸ê°€?
   â†’ í•œ ë¬¸ì¥ìœ¼ë¡œ ì„¤ëª… ê°€ëŠ¥? (ì˜ˆ: "Post card display and interactions")

2. 5ê°œ ì´ìƒì˜ private ë©”ì„œë“œ/ìœ„ì ¯ì´ ìˆëŠ”ê°€?
   â†’ YES: ë¶„ë¦¬ ê³ ë ¤

3. ì—¬ëŸ¬ Repository/Serviceë¥¼ í˜¸ì¶œí•˜ëŠ”ê°€?
   â†’ YES: ì±…ì„ì´ ì„ì˜€ì„ ê°€ëŠ¥ì„± ë†’ìŒ

4. Yellow Zone ì´ìƒì¸ê°€?
   â”œâ”€ YES + ë‹¨ì¼ ì±…ì„ ëª…í™• â†’ OK, ìœ ì§€
   â””â”€ YES + ì—¬ëŸ¬ ì±…ì„ ì„ì„ â†’ ë¶„ë¦¬ í•„ìš”

5. ìƒìˆ˜ ë°ì´í„°ê°€ ëŒ€ë¶€ë¶„ì¸ê°€?
   â†’ YES: JSON íŒŒì¼ë¡œ ì´ë™
```

**ê²°ë¡ **: ì¤„ ìˆ˜ëŠ” ì°¸ê³ ìš©. **ë‹¨ì¼ ì±…ì„**ì´ í•µì‹¬ íŒë‹¨ ê¸°ì¤€ì…ë‹ˆë‹¤.

### Testing Strategy

**Current Status** (As of 2025):
- **Test Files**: 3 files
  - `test/features/auth/data/auth_user_session_test.dart`
  - `test/features/community/data/services/interaction_cache_manager_test.dart` âœ… (ëª¨ë²” ì‚¬ë¡€)
  - `test/models_roundtrip_test.dart`
- **Overall Coverage**: <2%
- **Status**: ğŸš§ Infrastructure ready, gradual expansion needed

---

**Tier-Based Approach** (ê³„ì¸µë³„ ìš°ì„ ìˆœìœ„):

### ğŸ”´ Tier 1 - Critical Path (ë°˜ë“œì‹œ í…ŒìŠ¤íŠ¸)

**ê¸ˆìœµ ë¡œì§ ìˆ˜ì¤€ì˜ ì •í™•ë„ í•„ìš”**:

```bash
# ê¸‰ì—¬ ê³„ì‚° (ìµœìš°ì„ !)
test/features/calculator/domain/services/salary_calculation_service_test.dart

# ì—°ê¸ˆ ê³„ì‚°
test/features/calculator/domain/services/pension_calculation_service_test.dart

# ì¸ì¦ ë° ê¶Œí•œ
test/features/auth/presentation/cubit/auth_cubit_test.dart
test/features/community/domain/services/lounge_access_service_test.dart

# ê²°ì œ/í¬ì¸íŠ¸ (ìˆë‹¤ë©´)
test/features/*/payment_*_test.dart
```

**ëª©í‘œ ì»¤ë²„ë¦¬ì§€**: **90%+**

**ì´ìœ **:
- ê¸‰ì—¬/ì—°ê¸ˆ ê³„ì‚° ì˜¤ë¥˜ â†’ ì‚¬ìš©ì ì‹ ë¢° ìƒì‹¤
- ì¸ì¦ ì˜¤ë¥˜ â†’ ë³´ì•ˆ ë¬¸ì œ
- ê¸ˆì „ì  ì˜í–¥ì´ ì§ì ‘ì 

**ìš°ì„ ìˆœìœ„**:
1. Week 1-2: ê¸‰ì—¬ ê³„ì‚° í…ŒìŠ¤íŠ¸
2. Week 3-4: ì—°ê¸ˆ ê³„ì‚° í…ŒìŠ¤íŠ¸
3. Week 5-6: ì¸ì¦ ë¡œì§ í…ŒìŠ¤íŠ¸

---

### ğŸŸ¡ Tier 2 - Core Business Logic (ì ê·¹ í…ŒìŠ¤íŠ¸)

**ë°ì´í„° ë¬´ê²°ì„± ë° ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**:

```bash
# Repositories
test/features/*/data/repositories/*_repository_test.dart

# Domain Services
test/features/*/domain/services/*_service_test.dart

# Cache Managers
test/features/*/data/services/*_cache_manager_test.dart
test/features/*/data/services/*_enrichment_service_test.dart
```

**ëª©í‘œ ì»¤ë²„ë¦¬ì§€**:
- **Repositories**: 60%+
- **Services**: 70%+

**ì´ìœ **:
- ë°ì´í„° ì¼ê´€ì„± ë³´ì¥
- ìºì‹± ë¡œì§ ê²€ì¦
- API ê³„ì•½ ì¤€ìˆ˜

**í…ŒìŠ¤íŠ¸ íŒ¨í„´**:
```dart
// Repository í…ŒìŠ¤íŠ¸
test('should return Right(data) when fetch succeeds', () async {
  when(() => dataSource.fetchPosts()).thenAnswer((_) async => [mockPost]);

  final result = await repository.fetchPosts();

  expect(result, Right([mockPost]));
  verify(() => dataSource.fetchPosts()).called(1);
});

test('should return Left(ServerFailure) when network fails', () async {
  when(() => dataSource.fetchPosts()).thenThrow(ServerException());

  final result = await repository.fetchPosts();

  expect(result, isA<Left<Failure, List<Post>>>());
});

// Service í…ŒìŠ¤íŠ¸
test('should return cached data when cache is fresh', () {
  cacheManager.updateCache(uid: 'user1', likedIds: {'post1'});

  expect(cacheManager.shouldRefreshCache(), isFalse);
  expect(cacheManager.getCachedLikedIds('user1'), {'post1'});
});
```

---

### ğŸŸ¢ Tier 3 - Presentation Layer (ì„ íƒì )

**UI ìƒíƒœ ê´€ë¦¬**:

```bash
# Cubits (complex state)
test/features/*/presentation/cubit/*_cubit_test.dart

# Widgets (complex only)
test/features/*/presentation/widgets/*_test.dart
```

**ëª©í‘œ ì»¤ë²„ë¦¬ì§€**:
- **Cubits**: 40%+
- **Widgets**: 10-20% (ë³µì¡í•œ ê²ƒë§Œ)

**ì´ìœ **:
- UIëŠ” ë¹ ë¥´ê²Œ ë³€í•˜ë¯€ë¡œ í…ŒìŠ¤íŠ¸ ìœ ì§€ë¹„ìš© ê³ ë ¤
- Cubitì€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ í¬í•¨ ì‹œ í…ŒìŠ¤íŠ¸
- Widgetì€ ë³µì¡í•œ ì¡°ê±´ë¶€ ë Œë”ë§ë§Œ í…ŒìŠ¤íŠ¸

**í…ŒìŠ¤íŠ¸ íŒ¨í„´**:
```dart
// Cubit í…ŒìŠ¤íŠ¸ (bloc_test ì‚¬ìš©)
blocTest<CommunityCubit, CommunityState>(
  'emits [loading, loaded] when fetchPosts succeeds',
  build: () => CommunityCubit(repository: mockRepository),
  act: (cubit) => cubit.fetchPosts(),
  expect: () => [
    CommunityState.loading(),
    CommunityState.loaded(posts: mockPosts),
  ],
  verify: (_) {
    verify(() => mockRepository.fetchPosts()).called(1);
  },
);

// Widget í…ŒìŠ¤íŠ¸ (ë³µì¡í•œ ê²ƒë§Œ)
testWidgets('should render error state when data fails', (tester) async {
  await tester.pumpWidget(
    MaterialApp(
      home: BlocProvider.value(
        value: cubitWithError,
        child: MyComplexWidget(),
      ),
    ),
  );

  expect(find.text('Error occurred'), findsOneWidget);
  expect(find.byType(RetryButton), findsOneWidget);
});
```

---

### ğŸ“Š Overall Project Coverage Goals

**í˜„ì‹¤ì  Timeline**:

| Phase | Duration | Target | Focus |
|-------|----------|--------|-------|
| Phase 1 | Week 1-4 | Overall ~8% | Tier 1 ê¸‰ì—¬/ì—°ê¸ˆ 90%+ |
| Phase 2 | Month 2-3 | Overall ~20% | Tier 2 Repositories 60%+ |
| Phase 3 | Month 4-6 | Overall ~30% | Tier 2 Services 70%+ |
| Phase 4 | Month 7-12 | Overall ~50% | Tier 3 Cubits 40%+ |

**ì´ìœ **:
- í˜„ì¬ <2%ì—ì„œ 40%ëŠ” ë¹„í˜„ì‹¤ì 
- Tier 1 ì§‘ì¤‘ì´ ì‚¬ìš©ìì—ê²Œ ê°€ì¥ ì¤‘ìš”
- ì ì§„ì  ì¦ê°€ê°€ ì§€ì† ê°€ëŠ¥

**Milestone ì²´í¬í¬ì¸íŠ¸**:
- âœ… Month 1: ê¸‰ì—¬ ê³„ì‚° 90%+ â†’ "ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ê³„ì‚°ê¸°"
- âœ… Month 3: Repository 60%+ â†’ "ë°ì´í„° ë¬´ê²°ì„± ë³´ì¥"
- âœ… Month 6: Overall 30%+ â†’ "ì—…ê³„ ìŠ¤íƒ€íŠ¸ì—… í‰ê·  ë„ë‹¬"
- âœ… Year 1: Overall 50%+ â†’ "ê²¬ê³ í•œ í”„ë¡œì íŠ¸"

---

### ğŸ¯ Coverage != Quality

**ì¤‘ìš”í•œ ì›ì¹™**:

```
âœ… 80%ì˜ ì˜ë¯¸ ìˆëŠ” í…ŒìŠ¤íŠ¸ >> 100%ì˜ í˜•ì‹ì  í…ŒìŠ¤íŠ¸

// âŒ Bad: í˜•ì‹ì  í…ŒìŠ¤íŠ¸
test('model has correct fields', () {
  expect(post.id, isNotNull); // ì˜ë¯¸ ì—†ìŒ
});

// âœ… Good: ì˜ë¯¸ ìˆëŠ” í…ŒìŠ¤íŠ¸
test('should calculate net salary correctly with grade 15', () {
  final salary = service.calculateNetSalary(
    grade: 15,
    allowances: Allowance(family: 100000),
  );

  expect(salary.gross, 3500000); // ì‹¤ì œ ê³„ì‚° ê²€ì¦
  expect(salary.tax, 350000);
  expect(salary.net, 3150000);
});
```

**í…ŒìŠ¤íŠ¸í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ” ê²ƒ**:
- Generated code (ì—†ì§€ë§Œ)
- ë‹¨ìˆœ getter/setter
- í”„ë ˆì„ì›Œí¬ ì½”ë“œ (Flutter/Firebase)
- ë‹¨ìˆœ UI ì• ë‹ˆë©”ì´ì…˜

**ë°˜ë“œì‹œ í…ŒìŠ¤íŠ¸í•´ì•¼ í•˜ëŠ” ê²ƒ**:
- ê¸‰ì—¬/ì—°ê¸ˆ ê³„ì‚° ë¡œì§
- ì¸ì¦ ë° ê¶Œí•œ ë¡œì§
- ë°ì´í„° ë³€í™˜ ë¡œì§
- ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§
- ìºì‹± ë¡œì§

---

### ğŸ›  Mocking Strategy

**Use mocktail for dependencies**:

```dart
// Mock repositories
class MockCommunityRepository extends Mock implements CommunityRepository {}
class MockAuthCubit extends MockBloc<AuthState> implements AuthCubit {}

// DON'T mock
// âŒ Entities (Post, Comment, User)
// âŒ Value objects (CareerTrack, Allowance)
// âŒ Simple data models
```

---

### ğŸ“ˆ Measuring Success

**Coverage ëª…ë ¹ì–´**:
```bash
# Run tests with coverage
flutter test --coverage

# Generate HTML report
genhtml coverage/lcov.info -o coverage/html

# View report
open coverage/html/index.html
```

**CI/CD Integration**:
```yaml
# .github/workflows/test.yml
- name: Run tests
  run: flutter test --coverage

- name: Check Tier 1 coverage
  run: |
    # Tier 1 (ê¸‰ì—¬/ì—°ê¸ˆ) must be 90%+
    # Fail build if below threshold
```

**Coverage Badges** (optional):
```markdown
[![Coverage](https://img.shields.io/badge/coverage-15%25-yellow.svg)]()
[![Tier 1](https://img.shields.io/badge/tier%201-90%25-brightgreen.svg)]()
```

### Linting & Code Quality

- **Base**: flutter_lints (in analysis_options.yaml)
- **Enhanced**: very_good_analysis (available in dev dependencies)
- **Custom rules**: `prefer_const_constructors`, `prefer_const_literals_to_create_immutables`
- **Excluded**: `lib/generated_plugin_registrant.dart`

**Commands**:
```bash
flutter analyze
dart format lib test
flutter test --coverage
```

### Error Tracking

- **Production**: Sentry Flutter (crash reporting, error monitoring)
- **Development**: Firebase Crashlytics

### Code Conventions

**Architecture**:
- Follow Material 3 design guidelines
- Use BLoC/Cubit for state management
- Implement repository pattern for data access
- Isolate Firebase logic in data layer
- Use GetIt for dependency injection (manual registration)
- Use Dartz's `Either<Failure, Success>` for error handling

**Code Quality**:
- Prefer const constructors for performance
- Handle errors gracefully with user feedback
- Write unit tests for business logic
- Dispose resources properly (StreamSubscription, Controllers, Timers)

## Performance & Cost Optimization

### Caching Strategy

**When to Cache**:
- Frequently accessed, rarely changed data
- Expensive Firestore queries (multiple document reads)
- User-specific interactions (likes, bookmarks, view history)
- Computed/aggregated data

**Cache TTL Guidelines**:
- Real-time data (chat): No cache or 30 seconds
- User interactions (likes, bookmarks): 5-10 minutes
- User profiles: 15-30 minutes
- Static content (app settings): 1-24 hours

**Example Pattern**:
```dart
class InteractionCacheManager {
  static const Duration _cacheTTL = Duration(minutes: 10);
  DateTime? _lastCacheUpdate;
  
  bool shouldRefreshCache() {
    if (_lastCacheUpdate == null) return true;
    return DateTime.now().difference(_lastCacheUpdate!) > _cacheTTL;
  }
  
  Map<String, int> getCacheStats() {
    return {
      'hitCount': _cacheHitCount,
      'missCount': _cacheMissCount,
      'savedCost': _cacheHitCount * 2, // Each hit saves 2 Firestore reads
    };
  }
}
```

### Firebase Cost Optimization

**Query Best Practices**:
```dart
// âœ… Good: Use limit for pagination
await postsRef.orderBy('createdAt', descending: true).limit(20).get();

// âœ… Good: Batch queries
await postsRef.where(FieldPath.documentId, whereIn: postIds.take(10)).get();

// âŒ Bad: N+1 queries
for (final postId in postIds) {
  await postsRef.doc(postId).get(); // Expensive!
}

// âŒ Bad: No pagination
await postsRef.orderBy('createdAt').get(); // Gets ALL documents!
```

**Cost Reduction Checklist**:
- âœ… Implement pagination with `.limit()`
- âœ… Cache frequently accessed data
- âœ… Use composite indexes for complex queries
- âœ… Batch reads using `whereIn` (max 10 items per query)
- âŒ Never query entire collections
- âŒ Avoid `.get()` calls inside loops

### Memory Management

**Must Dispose**:
- StreamSubscription
- AnimationController
- TextEditingController
- Timer
- ScrollController
- FocusNode

**Performance Best Practices**:
```dart
// âœ… Use const for static widgets
const Text('Static Label');

// âœ… Extract widgets to reduce rebuilds
class _StaticHeader extends StatelessWidget {
  const _StaticHeader();
}

// âœ… Use keys for list items
ListView.builder(
  itemBuilder: (context, index) {
    return PostCard(
      key: ValueKey(posts[index].id),
      post: posts[index],
    );
  },
);
```

### Image Optimization

**Compression Guidelines**:
```dart
enum ImageCompressionType {
  profile,   // 90%
  post,      // 85%
  comment,   // 80%
  thumbnail, // 70%
}
```

**Best Practices**:
- âœ… Compress before upload
- âœ… Use `cached_network_image` for network images
- âœ… Set `maxWidth` and `maxHeight` when picking
- âœ… Use thumbnails for list views
- âŒ Don't upload raw camera images (can be 5-10MB!)

## Firebase Integration

### Configuration

- Firestore: Primary database
- Firebase Auth: User authentication
- Firebase Storage: File uploads
- Firebase Messaging: Push notifications
- Indexes: Defined in `firestore.indexes.json`
- Emulator: Configured for local development

### Firebase Functions

**Single unified codebase** (`functions/`) handles all backend services:

**Core Features**:
- Community (posts, comments, likes, hot score calculation)
- Paystub Verification (OCR via Vision API, career track detection)
- Email Verification (government email authentication)
- Notifications (push messaging)
- User Management (profile updates, verification status)
- Data Migration utilities

**Tech Stack**:
- Runtime: TypeScript, Node 22
- Core: firebase-admin, firebase-functions
- OCR & Vision: @google-cloud/storage, @google-cloud/vision
- Utilities: nodemailer, pdf-parse

**Development**:
```bash
cd functions
npm install
npm run build
npm run serve  # Start emulator
firebase deploy --only functions
```

**Note**: The `paystub-functions/` directory exists but is not actively used (legacy codebase).

## Troubleshooting

### Common Build Errors

**Q: Gradle build fails with "Execution failed for task ':app:processDebugGoogleServices'"**
```bash
cd android && ./gradlew clean
cd .. && flutter clean && flutter pub get
```

**Q: CocoaPods error on iOS**
```bash
cd ios
pod cache clean --all
pod install
cd ..
```

### Firebase Issues

**Q: "Firebase not initialized" error**
- Ensure `firebase_options.dart` exists in `lib/`
- Verify `Firebase.initializeApp()` is called in `main.dart`

**Q: Functions emulator won't start**
- Check port conflicts (default: 5001 for Functions)
- Change ports in `firebase.json` if needed
- Ensure Node.js 22+ is installed

**Q: Vision API errors in Functions**
- Verify service account has Vision API permissions
- Check `serviceAccountKey.json` is present and valid
- Ensure Vision API is enabled in Google Cloud Console

### Development Issues

**Q: Hot reload not working**
- Restart app completely
- Check for errors in terminal
- Try `flutter clean && flutter pub get`

**Q: Dependency conflicts**
```bash
flutter clean
flutter pub get
flutter pub upgrade
```

**Q: Emulator UI not accessible**
- Check if running: `firebase emulators:start`
- Access at: http://localhost:4000
- Check firewall settings

## Contributing

### Before Starting

1. Read this CLAUDE.md thoroughly
2. Check existing issues/PRs to avoid duplication
3. Discuss major changes in issues first
4. Follow file size and architectural guidelines

### Development Process

1. **Create Feature Branch**:
   ```bash
   git checkout -b feat/your-feature-name
   ```

2. **Write Tests** (50%+ coverage for new features):
   - Unit tests for business logic
   - Widget tests for complex UI
   - BLoC tests for state management

3. **Code Quality Checks**:
   ```bash
   flutter analyze  # Fix all issues
   dart format lib test  # Format code
   flutter test  # All tests must pass
   ```

4. **Submit PR**:
   - Clear, descriptive title
   - Link related issues
   - Describe changes and rationale
   - Include screenshots for UI changes

### Code Review Criteria

- âœ… Follows BLoC/Cubit pattern
- âœ… No code generation dependencies
- âœ… Proper error handling with `Either<Failure, Data>`
- âœ… File size within guidelines
- âœ… Tests written and passing
- âœ… No lint errors
- âœ… Properly disposed resources

### PR Checklist

- [ ] Tests written (50%+ coverage for new code)
- [ ] `flutter analyze` passes with no errors
- [ ] Code formatted with `dart format`
- [ ] No prohibited dependencies (freezed, build_runner, etc.)
- [ ] Follows architectural patterns
- [ ] Documentation updated if needed
- [ ] Tested on both Android and iOS

## Known Issues & Roadmap

### Current Limitations

**Test Coverage**:
- Overall coverage <2%
- Only 3 test files exist
- Critical paths (auth, payments, calculations) need tests
- Gradual expansion to 40%+ planned

**Technical Debt**:
- `post_card.dart` needs refactoring (860 lines, Red Zone)
- `community_repository.dart` should be split (738 lines, Orange Zone)
- Some widgets still use StatefulWidget (migration to Cubit planned)
- `paystub-functions/` directory unused (legacy code)

### In Development

**Year-End Tax Feature**:
- Domain layer complete
- Data and presentation layers in progress
- Target: Q1 2025

**Test Expansion**:
- Auth module tests (Priority 1)
- Calculator/Pension calculation tests (Priority 2)
- Community cache manager tests (In progress)

### Roadmap

**Short-term (Q1 2025)**:
- Complete year-end tax feature
- Expand test coverage to 20%+
- Refactor large files (post_card.dart, community_repository.dart)
- Implement analytics dashboard

**Mid-term (Q2-Q3 2025)**:
- Reach 40%+ overall test coverage
- Performance optimization (reduce Firestore costs by 30%)
- Implement advanced search features
- Add career progression planning tools

**Long-term (Q4 2025+)**:
- AI-powered salary negotiation insights
- Integration with government HR systems
- Mobile web version (PWA)
- Multi-language support

### Reporting Issues

When reporting issues, include:
1. Flutter version (`flutter --version`)
2. Device/emulator details
3. Steps to reproduce
4. Expected vs actual behavior
5. Error logs/screenshots
6. Related code snippets

---

**For questions or clarifications, contact the team lead or open an issue in the repository.**
