rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function hasOnlyKeys(data, keys) {
      return data.keys().hasOnly(keys);
    }

    function hasAllKeys(data, keys) {
      return data.keys().hasAll(keys);
    }

    function notificationAllowedKeys() {
      return [
        'type',
        'title',
        'body',
        'payload',
        'data',  // Functions에서 사용하는 data 필드 추가
        'createdAt',
        'delivered',
        'deliveredAt',
        'read'
      ];
    }

    function isValidNotificationCreate(data) {
      return hasOnlyKeys(data, notificationAllowedKeys()) &&
        hasAllKeys(data, ['type', 'title', 'body', 'createdAt', 'delivered', 'read']) &&
        data.type is string &&
        data.title is string &&
        data.body is string &&
        (data.payload == null || data.payload is map) &&
        (data.data == null || data.data is map) &&  // data 필드 검증 추가
        data.createdAt is timestamp &&
        data.delivered == false &&
        data.read == false &&
        (!data.keys().hasAny(['deliveredAt']) || data.deliveredAt == null);
    }

    function isValidNotificationUpdate(newData, existingData) {
      return hasOnlyKeys(newData, notificationAllowedKeys()) &&
        newData.type == existingData.type &&
        newData.title == existingData.title &&
        newData.body == existingData.body &&
        newData.payload == existingData.payload &&
        newData.data == existingData.data &&  // data 필드는 변경 불가
        newData.createdAt == existingData.createdAt &&
        (newData.delivered == existingData.delivered ||
          (existingData.delivered == false && newData.delivered == true)) &&
        (newData.read == existingData.read ||
          (existingData.read == false && newData.read == true)) &&
        (newData.delivered is bool) &&
        (newData.read is bool) &&
        (newData.deliveredAt == existingData.deliveredAt ||
          (newData.deliveredAt == null && newData.delivered == false) ||
          (newData.deliveredAt is timestamp && newData.delivered == true));
    }

    function isTimestampOrServer(value) {
      return value is timestamp || value == request.time;
    }

    // 4-Level Access Control: Lounge Write Access
    // Level 2+ required (emailVerified OR careerTrackVerified)
    function hasLoungeWriteAccess() {
      return isSignedIn() && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('emailVerified', false) == true ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('careerTrackVerified', false) == true
      );
    }

    function isValidPaystubClientWrite(data) {
      return hasOnlyKeys(data, [
          'status',
          'uploadedAt',
          'updatedAt',
          'detectedTrack',
          'detectedKeywords',
          'errorMessage',
          'originalFileName'
        ]) &&
        hasAllKeys(data, [
          'status',
          'uploadedAt',
          'updatedAt',
          'detectedKeywords',
          'originalFileName'
        ]) &&
        data.status == 'processing' &&
        data.originalFileName is string &&
        data.originalFileName.size() > 0 &&
        (data.detectedTrack == null) &&
        (data.errorMessage == null) &&
        (data.detectedKeywords is list) &&
        isTimestampOrServer(data.uploadedAt) &&
        isTimestampOrServer(data.updatedAt);
    }

    match /users/{userId} {
      allow get: if isSignedIn();       // 개별 사용자 조회 허용
      allow list: if false;             // 🔒 전체 목록 조회 차단 (대량 수집 방지)
      allow create: if isOwner(userId);
      allow delete: if isOwner(userId);

      // 본인 문서 전체 업데이트
      allow update: if isOwner(userId);

      // 팔로우 시스템: 다른 사용자가 followerCount 업데이트 가능 (팔로우 받을 때)
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followerCount', 'updatedAt']);

      // 팔로우 시스템: 다른 사용자가 followingCount 업데이트 가능 (언팔로우할 때)
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followingCount', 'updatedAt']);

      match /badges/{badgeId} {
        allow read: if isSignedIn();
        allow create, update, delete: if isOwner(userId);
      }

      match /notifications/{notificationId} {
        allow read: if isOwner(userId);
        allow create: if isSignedIn() &&
          isValidNotificationCreate(request.resource.data);
        allow update: if isOwner(userId) &&
          isValidNotificationUpdate(request.resource.data, resource.data);
        allow delete: if isOwner(userId);  // 본인 알림 삭제 가능
      }

      match /verifications/{verificationId} {
        allow read: if isOwner(userId);
        allow create, update: if isOwner(userId) &&
          verificationId == 'paystub' &&
          isValidPaystubClientWrite(request.resource.data);
        allow delete: if false;
      }

      match /scraps/{postId} {
        allow read: if isOwner(userId);
        allow create, update, delete: if isOwner(userId);
      }

      // Follow System - 팔로우/팔로워 관리
      match /followers/{followerId} {
        allow read: if isSignedIn();
        // followerId는 팔로우하는 사람의 uid여야 하고, 본인만 팔로우 가능
        allow create, delete: if isSignedIn() && followerId == request.auth.uid;
      }

      match /following/{targetUid} {
        allow read: if isSignedIn();
        // userId가 본인이어야만 following 목록 조작 가능
        allow create, delete: if isSignedIn() && isOwner(userId);
      }

      // 🔒 차단 사용자 목록 (본인만 접근 가능)
      match /blocked_users/{blockedUid} {
        allow read, write: if isOwner(userId);
      }

      // 🔒 민감 정보 저장용 서브컬렉션 (본인만 접근 가능)
      match /private/{docId} {
        allow read, write: if isOwner(userId);
      }
    }

    match /handles/{handle} {
      allow get, list, read: if isSignedIn();
      allow create: if isSignedIn() &&
        request.resource.data.keys().hasOnly(['uid']) &&
        request.resource.data.uid == request.auth.uid;
      allow update: if false;
      allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;
    }

    match /government_email_index/{docId} {
      allow get: if isSignedIn();
      allow list: if false;  // 🔒 대량 조회 차단
      allow create, update: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;
      allow delete: if false;
    }

    match /government_email_aliases/{docId} {
      allow get: if isSignedIn();
      allow list: if false;  // 🔒 대량 조회 차단
      allow create, update: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;
      allow delete: if false;
    }

    match /government_email_verification_tokens/{tokenId} {
      allow get: if isSignedIn();
      allow list: if false;  // 🔒 대량 조회 차단
      allow create, update: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;
      allow delete: if false;
    }

    match /posts/{postId} {
      allow get, list, read: if isSignedIn();
      allow create: if hasLoungeWriteAccess();  // Level 2+ (emailVerified or careerTrackVerified)
      allow update: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // 본인 글만 수정 가능
      // Allow anyone to update likeCount, commentCount, viewCount, and updatedAt (for interactions)
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likeCount', 'updatedAt']);
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentCount', 'updatedAt']);
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount', 'updatedAt']);
      allow delete: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // 본인 글만 삭제 가능 (authorId → authorUid 수정)

      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if hasLoungeWriteAccess();  // Level 2+ (emailVerified or careerTrackVerified)
        allow update: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // 본인 댓글만 수정 가능
        allow delete: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // 본인 댓글만 삭제 가능
      }

      match /comment_likes/{docId} {
        allow read: if isSignedIn();
        // docId format: {commentId}_{uid}
        allow write: if isSignedIn() && docId.matches('.*_' + request.auth.uid + '$');
      }
    }

    match /likes/{docId} {
      allow read: if isSignedIn();
      // docId format: {postId}_{uid}
      allow write: if isSignedIn() && docId.matches('.*_' + request.auth.uid + '$');
    }

    match /post_counters/{postId} {
      match /shards/{shardId} {
        allow read: if isSignedIn();
        allow create, update, delete: if isSignedIn();
      }
    }

    match /boards/{boardId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /search_suggestions/{token} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn();
      allow delete: if false;
    }

    match /reports/{reportId} {
      allow read: if false;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    match /lounges/{loungeId} {
      allow read: if isSignedIn();
      allow write: if false; // 라운지 정보는 관리자만 수정 가능
    }

    // Collection group query for comments
    // Allows fetching all comments across all posts (e.g., for user profile)
    match /{path=**}/comments/{commentId} {
      allow read: if isSignedIn();
    }
  }
}
