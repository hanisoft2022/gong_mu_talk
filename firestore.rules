rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection
    match /users/{userId} {
      // Allow authenticated reads of user profiles (needed for listings/queries)
      allow get, list, read: if request.auth != null;

      // Allow users to create or update only their own document
      allow create, update: if request.auth != null && request.auth.uid == userId;

      // Restrict deletes to self as well (or lock it down completely if desired)
      allow delete: if request.auth != null && request.auth.uid == userId;

      // Subcollections under users
      // Badges: user can read and write their own badges
      match /badges/{badgeId} {
        allow read: if request.auth != null;
        allow create, update, delete: if request.auth != null && request.auth.uid == userId;
      }

      // Matching likes: user can manage their own likes
      match /matching_likes/{targetUid} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create, update, delete: if request.auth != null && request.auth.uid == userId;
      }

      // Matching inbox: other users can write a like addressed to userId
      match /matching_inbox/{senderUid} {
        // Recipient can read their inbox
        allow read: if request.auth != null && request.auth.uid == userId;
        // Only the sender may create/update/delete their own entry in someone else's inbox
        allow create, update, delete: if request.auth != null && request.auth.uid == senderUid;
      }

      // Matching meta (e.g., exposure counters): only owner may update
      match /matching_meta/{docId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        allow create, update, delete: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Handles collection used for unique nickname reservation
    match /handles/{handle} {
      // Anyone authenticated can check if a handle exists
      allow get, list, read: if request.auth != null;

      // Allow creating a handle doc only when the stored uid matches the caller
      allow create: if request.auth != null &&
        request.resource.data.keys().hasOnly(['uid']) &&
        request.resource.data.uid == request.auth.uid;

      // Prevent updates/deletes in normal flow
      allow update, delete: if false;
    }

    // Matches collection (top-level): only participants can read/write
    match /matches/{matchId} {
      allow read: if request.auth != null &&
        (resource.data.userA == request.auth.uid || resource.data.userB == request.auth.uid);

      allow create, update: if request.auth != null &&
        (request.resource.data.userA == request.auth.uid || request.resource.data.userB == request.auth.uid);

      // Typically no deletes; restrict to participants if needed
      allow delete: if request.auth != null &&
        (resource.data.userA == request.auth.uid || resource.data.userB == request.auth.uid);
    }

    // Government email claim index: stores mapping and verification status
    match /government_email_index/{docId} {
      // Authenticated users can read to resolve/verify their email state
      allow get, list, read: if request.auth != null;

      // Allow users to create/update their own claim entries
      allow create, update: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      // No deletes by clients
      allow delete: if false;
    }

    // Government email aliases: legacyEmail -> governmentEmail mapping
    match /government_email_aliases/{docId} {
      // Authenticated reads to resolve linkage
      allow get, list, read: if request.auth != null;

      // Allow create/update when alias belongs to caller
      allow create, update: if request.auth != null &&
        request.resource.data.userId == request.auth.uid;

      allow delete: if false;
    }

    // Community: posts
    match /posts/{postId} {
      // Public read of posts
      allow get, list, read: if request.auth != null;

      // Any authenticated user can create/update posts (author enforced in app)
      allow create, update: if request.auth != null;
      // No client deletes; use soft-delete via update
      allow delete: if false;

      // Post subcollections
      match /comments/{commentId} {
        allow read: if request.auth != null;
        allow create, update: if request.auth != null;
        allow delete: if false;
      }

      match /comment_likes/{docId} {
        allow read: if request.auth != null;
        allow create, update, delete: if request.auth != null;
      }
    }

    // Likes (post likes stored top-level)
    match /likes/{docId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth != null;
    }

    // Post counter shards
    match /post_counters/{postId} {
      match /shards/{shardId} {
        allow read: if request.auth != null;
        allow create, update, delete: if request.auth != null;
      }
    }

    // Boards are public readable
    match /boards/{boardId} {
      allow read: if request.auth != null;
      allow write: if false;
    }

    // Search suggestions increment
    match /search_suggestions/{token} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null;
      allow delete: if false;
    }

    // Content reports
    match /reports/{reportId} {
      allow read: if false;
      allow create: if request.auth != null;
      allow update, delete: if false;
    }

    // Bookmarks under users: owner only
    match /users/{userId}/bookmarks/{postId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create, update, delete: if request.auth != null && request.auth.uid == userId;
    }
  }
}