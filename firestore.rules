rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function hasOnlyKeys(data, keys) {
      return data.keys().hasOnly(keys);
    }

    function hasAllKeys(data, keys) {
      return data.keys().hasAll(keys);
    }

    function notificationAllowedKeys() {
      return [
        'type',
        'title',
        'body',
        'payload',
        'data',  // Functionsì—ì„œ ì‚¬ìš©í•˜ëŠ” data í•„ë“œ ì¶”ê°€
        'createdAt',
        'delivered',
        'deliveredAt',
        'read'
      ];
    }

    function isValidNotificationCreate(data) {
      return hasOnlyKeys(data, notificationAllowedKeys()) &&
        hasAllKeys(data, ['type', 'title', 'body', 'createdAt', 'delivered', 'read']) &&
        data.type is string &&
        data.title is string &&
        data.body is string &&
        (data.payload == null || data.payload is map) &&
        (data.data == null || data.data is map) &&  // data í•„ë“œ ê²€ì¦ ì¶”ê°€
        data.createdAt is timestamp &&
        data.delivered == false &&
        data.read == false &&
        (!data.keys().hasAny(['deliveredAt']) || data.deliveredAt == null);
    }

    function isValidNotificationUpdate(newData, existingData) {
      return hasOnlyKeys(newData, notificationAllowedKeys()) &&
        newData.type == existingData.type &&
        newData.title == existingData.title &&
        newData.body == existingData.body &&
        newData.payload == existingData.payload &&
        newData.data == existingData.data &&  // data í•„ë“œëŠ” ë³€ê²½ ë¶ˆê°€
        newData.createdAt == existingData.createdAt &&
        (newData.delivered == existingData.delivered ||
          (existingData.delivered == false && newData.delivered == true)) &&
        (newData.read == existingData.read ||
          (existingData.read == false && newData.read == true)) &&
        (newData.delivered is bool) &&
        (newData.read is bool) &&
        (newData.deliveredAt == existingData.deliveredAt ||
          (newData.deliveredAt == null && newData.delivered == false) ||
          (newData.deliveredAt is timestamp && newData.delivered == true));
    }

    function isTimestampOrServer(value) {
      return value is timestamp || value == request.time;
    }

    // 4-Level Access Control: Lounge Write Access
    // Level 2+ required (emailVerified OR careerTrackVerified)
    function hasLoungeWriteAccess() {
      return isSignedIn() && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('emailVerified', false) == true ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.get('careerTrackVerified', false) == true
      );
    }

    function isValidPaystubClientWrite(data) {
      return hasOnlyKeys(data, [
          'status',
          'uploadedAt',
          'updatedAt',
          'detectedTrack',
          'detectedKeywords',
          'errorMessage',
          'originalFileName'
        ]) &&
        hasAllKeys(data, [
          'status',
          'uploadedAt',
          'updatedAt',
          'detectedKeywords',
          'originalFileName'
        ]) &&
        data.status == 'processing' &&
        data.originalFileName is string &&
        data.originalFileName.size() > 0 &&
        (data.detectedTrack == null) &&
        (data.errorMessage == null) &&
        (data.detectedKeywords is list) &&
        isTimestampOrServer(data.uploadedAt) &&
        isTimestampOrServer(data.updatedAt);
    }

    match /users/{userId} {
      allow get: if isSignedIn();       // ê°œë³„ ì‚¬ìš©ì ì¡°íšŒ í—ˆìš©
      allow list: if false;             // ğŸ”’ ì „ì²´ ëª©ë¡ ì¡°íšŒ ì°¨ë‹¨ (ëŒ€ëŸ‰ ìˆ˜ì§‘ ë°©ì§€)
      allow create: if isOwner(userId);
      allow delete: if isOwner(userId);

      // ë³¸ì¸ ë¬¸ì„œ ì „ì²´ ì—…ë°ì´íŠ¸
      allow update: if isOwner(userId);

      // íŒ”ë¡œìš° ì‹œìŠ¤í…œ: ë‹¤ë¥¸ ì‚¬ìš©ìê°€ followerCount ì—…ë°ì´íŠ¸ ê°€ëŠ¥ (íŒ”ë¡œìš° ë°›ì„ ë•Œ)
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followerCount', 'updatedAt']);

      // íŒ”ë¡œìš° ì‹œìŠ¤í…œ: ë‹¤ë¥¸ ì‚¬ìš©ìê°€ followingCount ì—…ë°ì´íŠ¸ ê°€ëŠ¥ (ì–¸íŒ”ë¡œìš°í•  ë•Œ)
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followingCount', 'updatedAt']);

      match /badges/{badgeId} {
        allow read: if isSignedIn();
        allow create, update, delete: if isOwner(userId);
      }

      match /notifications/{notificationId} {
        allow read: if isOwner(userId);
        allow create: if isSignedIn() &&
          isValidNotificationCreate(request.resource.data);
        allow update: if isOwner(userId) &&
          isValidNotificationUpdate(request.resource.data, resource.data);
        allow delete: if isOwner(userId);  // ë³¸ì¸ ì•Œë¦¼ ì‚­ì œ ê°€ëŠ¥
      }

      match /verifications/{verificationId} {
        allow read: if isOwner(userId);
        allow create, update: if isOwner(userId) &&
          verificationId == 'paystub' &&
          isValidPaystubClientWrite(request.resource.data);
        allow delete: if false;
      }

      match /scraps/{postId} {
        allow read: if isOwner(userId);
        allow create, update, delete: if isOwner(userId);
      }

      // Follow System - íŒ”ë¡œìš°/íŒ”ë¡œì›Œ ê´€ë¦¬
      match /followers/{followerId} {
        allow read: if isSignedIn();
        // followerIdëŠ” íŒ”ë¡œìš°í•˜ëŠ” ì‚¬ëŒì˜ uidì—¬ì•¼ í•˜ê³ , ë³¸ì¸ë§Œ íŒ”ë¡œìš° ê°€ëŠ¥
        allow create, delete: if isSignedIn() && followerId == request.auth.uid;
      }

      match /following/{targetUid} {
        allow read: if isSignedIn();
        // userIdê°€ ë³¸ì¸ì´ì–´ì•¼ë§Œ following ëª©ë¡ ì¡°ì‘ ê°€ëŠ¥
        allow create, delete: if isSignedIn() && isOwner(userId);
      }

      // ğŸ”’ ì°¨ë‹¨ ì‚¬ìš©ì ëª©ë¡ (ë³¸ì¸ë§Œ ì ‘ê·¼ ê°€ëŠ¥)
      match /blocked_users/{blockedUid} {
        allow read, write: if isOwner(userId);
      }

      // ğŸ”’ ë¯¼ê° ì •ë³´ ì €ì¥ìš© ì„œë¸Œì»¬ë ‰ì…˜ (ë³¸ì¸ë§Œ ì ‘ê·¼ ê°€ëŠ¥)
      match /private/{docId} {
        allow read, write: if isOwner(userId);
      }
    }

    match /handles/{handle} {
      allow get, list, read: if isSignedIn();
      allow create: if isSignedIn() &&
        request.resource.data.keys().hasOnly(['uid']) &&
        request.resource.data.uid == request.auth.uid;
      allow update: if false;
      allow delete: if isSignedIn() && resource.data.uid == request.auth.uid;
    }

    match /government_email_index/{docId} {
      allow get: if isSignedIn();
      allow list: if false;  // ğŸ”’ ëŒ€ëŸ‰ ì¡°íšŒ ì°¨ë‹¨
      allow create, update: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;
      allow delete: if false;
    }

    match /government_email_aliases/{docId} {
      allow get: if isSignedIn();
      allow list: if false;  // ğŸ”’ ëŒ€ëŸ‰ ì¡°íšŒ ì°¨ë‹¨
      allow create, update: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;
      allow delete: if false;
    }

    match /government_email_verification_tokens/{tokenId} {
      allow get: if isSignedIn();
      allow list: if false;  // ğŸ”’ ëŒ€ëŸ‰ ì¡°íšŒ ì°¨ë‹¨
      allow create, update: if isSignedIn() &&
        request.resource.data.userId == request.auth.uid;
      allow delete: if false;
    }

    match /posts/{postId} {
      allow get, list, read: if isSignedIn();
      allow create: if hasLoungeWriteAccess();  // Level 2+ (emailVerified or careerTrackVerified)
      allow update: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // ë³¸ì¸ ê¸€ë§Œ ìˆ˜ì • ê°€ëŠ¥
      // Allow anyone to update likeCount, commentCount, viewCount, and updatedAt (for interactions)
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likeCount', 'updatedAt']);
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentCount', 'updatedAt']);
      allow update: if isSignedIn() &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewCount', 'updatedAt']);
      allow delete: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // ë³¸ì¸ ê¸€ë§Œ ì‚­ì œ ê°€ëŠ¥ (authorId â†’ authorUid ìˆ˜ì •)

      match /comments/{commentId} {
        allow read: if isSignedIn();
        allow create: if hasLoungeWriteAccess();  // Level 2+ (emailVerified or careerTrackVerified)
        allow update: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // ë³¸ì¸ ëŒ“ê¸€ë§Œ ìˆ˜ì • ê°€ëŠ¥
        allow delete: if isSignedIn() && resource.data.authorUid == request.auth.uid;  // ë³¸ì¸ ëŒ“ê¸€ë§Œ ì‚­ì œ ê°€ëŠ¥
      }

      match /comment_likes/{docId} {
        allow read: if isSignedIn();
        // docId format: {commentId}_{uid}
        allow write: if isSignedIn() && docId.matches('.*_' + request.auth.uid + '$');
      }
    }

    match /likes/{docId} {
      allow read: if isSignedIn();
      // docId format: {postId}_{uid}
      allow write: if isSignedIn() && docId.matches('.*_' + request.auth.uid + '$');
    }

    match /post_counters/{postId} {
      match /shards/{shardId} {
        allow read: if isSignedIn();
        allow create, update, delete: if isSignedIn();
      }
    }

    match /boards/{boardId} {
      allow read: if isSignedIn();
      allow write: if false;
    }

    match /search_suggestions/{token} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn();
      allow delete: if false;
    }

    match /reports/{reportId} {
      allow read: if false;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    match /lounges/{loungeId} {
      allow read: if isSignedIn();
      allow write: if false; // ë¼ìš´ì§€ ì •ë³´ëŠ” ê´€ë¦¬ìë§Œ ìˆ˜ì • ê°€ëŠ¥
    }

    // Collection group query for comments
    // Allows fetching all comments across all posts (e.g., for user profile)
    match /{path=**}/comments/{commentId} {
      allow read: if isSignedIn();
    }
  }
}
